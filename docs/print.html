<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Higher-Order Typed Compilation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A transcription of my lecture notes from 15-417">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="index.html">Intro</a></li><li class="expanded "><a href="fw/index.html"><strong aria-hidden="true">1.</strong> Unit 1: System Fw</a></li><li><ol class="section"><li class="expanded "><a href="fw/system-f.html"><strong aria-hidden="true">1.1.</strong> Review: System F</a></li><li class="expanded "><a href="fw/declarative.html"><strong aria-hidden="true">1.2.</strong> Declarative system</a></li><li class="expanded "><a href="fw/algorithmic.html"><strong aria-hidden="true">1.3.</strong> Typechecking</a></li></ol></li><li class="expanded "><a href="singleton/index.html"><strong aria-hidden="true">2.</strong> Unit 2: Singleton kinds</a></li><li><ol class="section"><li class="expanded "><a href="singleton/declarative.html"><strong aria-hidden="true">2.1.</strong> Declarative system</a></li><li class="expanded "><a href="singleton/algorithmic.html"><strong aria-hidden="true">2.2.</strong> Algorithmic rules</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Higher-Order Typed Compilation</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#15-417-hot-compilation-spring-2020" id="15-417-hot-compilation-spring-2020">15-417 HOT Compilation, Spring 2020</a></h1>
<ul>
<li>Professor: Karl Crary</li>
<li>Scribe: Cameron Wong</li>
<li>Carnegie Mellon University</li>
</ul>
<p>Joining a grand tradition, I'm going to attempt and inevitably give up at
typesetting the notes for this class.</p>
<p>Material is grouped by subject and is roughly ordered by when we covered them
in class. There is no separation by individual lectures. The order of material
in a given subsection is, roughly following class presentation order, but may
be reordered according to what I personally find to be clearer.</p>
<p>These are somewhat inspired by Nick Roberts' attempt, and a lot of the early
material is... well, not lifted, but definitely influenced by his explanations.</p>
<p>I will do my best to keep my personal comments restricted to the remarks. Any
mistakes are mine. These notes will include no more SML code than was presented
in lecture.</p>
<h1><a class="header" href="#system-fw" id="system-fw">System Fw</a></h1>
<p>System \(F_\omega\) is a system of higher-kinded types and type-constructors. It
is relevant to compiling SML in the way that it relates to the module system.
If we extend the kind system of &quot;true&quot; \(F_\omega\) with product kinds, we might
represent the module signature</p>
<pre><code class="language-ocaml">sig
  type t
  type 'a u
end
</code></pre>
<p>as the kind \(* \times (* \rightarrow *)\), and so on. This even
extends to functors that act on modules via type-level lambdas.</p>
<h1><a class="header" href="#system-f" id="system-f">System F</a></h1>
<p>As a warmup to \(F_\omega\), a brief review of the rules for
System F.</p>
<p>\[\require{bussproofs}
\begin{aligned}
\tau &amp;:= \alpha \mid \tau \rightarrow \tau \mid \forall \alpha . \tau \\
e &amp;:= x \mid \lambda (x:\tau).e \mid e\ e \mid \Lambda \alpha.e \mid e[\tau]
\end{aligned}
\]</p>
<p>When typechecking System F, we use two judgments, \(\Gamma \vdash x:
\tau\) and \(\Gamma \vdash \tau:*\)<sup class="footnote-reference"><a href="#1">1</a></sup>. The latter is often written
\(\Gamma \vdash \tau\ type\), but we will use this notation so it becomes
familiar for the future.</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha)= * $}
\UnaryInfC{$\Gamma \vdash \alpha: * $}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1: * $}
\AxiomC{$\Gamma \vdash \tau_2: * $}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2: * $}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:* \vdash \tau : *$}
\UnaryInfC{$\Gamma \vdash \forall \alpha.\tau : *$}
\end{prooftree}
\]</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x : \tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, x:\tau_1 \vdash e:\tau_2$}
\UnaryInfC{$\Gamma \vdash \lambda (x:\tau_1) . e : \tau_1 \rightarrow \tau_2$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:* \vdash e:\tau$}
\UnaryInfC{$\Gamma \vdash \Lambda \alpha. e : \forall \alpha . \tau$}
\end{prooftree}
\]</p>
<p>The defining feature of System F is the \(\Lambda \alpha.e\) syntax form, with
its corresponding \(\forall \alpha.e\) type, the so-called &quot;type-lambdas&quot; or
&quot;polymorphic values&quot;. Just as value lambdas annotate their argument, we may
also choose to do so with type lambdas, as \(\Lambda (\alpha : *).e\). Then the
rule for typing big lambda expressions becomes</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:* \vdash e:\tau$}
\UnaryInfC{$\Gamma \vdash \Lambda (\alpha:*). e : \forall \alpha . \tau$}
\end{prooftree}
\]</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The kind of base types is officially \(T\) for \(type\), but I'm going to follow the Haskell convention of writing it as \(*\).</p>
</div>
<h1><a class="header" href="#system-f_omega" id="system-f_omega">System F\(_\omega^{++}\)</a></h1>
<p>\(F_\omega\) is the calculus of higher-kinded type constructors, combining two
axes of the lambda cube (polymorphism and type operators).</p>
<p>The syntax of \(F_\omega\) is an extension of \(F\). First, we need to
adjust our syntax to use type constructors (or just &quot;constructors&quot;) instead of
just types. By convention, we will use \(\tau\) to denote a nullary constructor,
a constructor kinded at \(*\) (see below).</p>
<p>\[\require{bussproofs}
c, \tau := \alpha \mid c \rightarrow c \mid \forall (\alpha : k).c
\mid \lambda (\alpha : k) .c \mid c\ c
\]</p>
<p>where \(\alpha\) is a type variable used in quantification and type abstraction.</p>
<p>Next, we will add \(k\), to denote kinds:</p>
<p>\[
k := * \mid k \rightarrow k
\]</p>
<p>We also need terms to inhabit those types:</p>
<p>\[
e := x \mid \lambda (x:\tau).e \mid \Lambda(\alpha:k).e \mid e[\tau]
\]</p>
<p>Our context, \(\Gamma\), may contain judgments about types and terms.</p>
<p>\[
\Gamma := \cdot \mid \Gamma, x:\tau \mid \Gamma : \alpha:k
\]</p>
<p>You may also see the kinding judgment written as \(\alpha :: k\).</p>
<p>Finally, as noted earlier, we will need to extend \(F_\omega\) with primitive
product kinds to handle ML modules (hence the ++ in \(F_\omega^{++}\)):</p>
<p>\[
\begin{aligned}
k &amp;:= \dots \mid k \times k \\
c &amp;:= \dots \mid \langle c, c \rangle \mid \pi_1 c \mid \pi_2 c
\end{aligned}
\]</p>
<p>This language is defined statically as follows:</p>
<p><strong>Rules 1.1 (Kinding)</strong>: \(\Gamma \vdash c:k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:*$}
\AxiomC{$\Gamma \vdash c_2:*$}
\BinaryInfC{$\Gamma \vdash c_1 \rightarrow c_2 : *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:*$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).c:*$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k \rightarrow k'$}
\AxiomC{$\Gamma \vdash c_2:k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 : k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:k'$}
\UnaryInfC{$\Gamma \vdash \lambda (\alpha:k).c : k \rightarrow k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle : k_1 \times k_2$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1 c : k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2 c : k_2$}
\end{prooftree}
\]</p>
<p><strong>Rules 1.2 (Typing)</strong>: \(\Gamma \vdash e:\tau\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, x:\tau \vdash e:\tau'$}
\AxiomC{$\Gamma \vdash \tau:*$}
\BinaryInfC{$\Gamma \vdash \lambda(x:\tau).e : \tau \rightarrow \tau'$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \vdash e_1:\tau \rightarrow \tau'$}
\AxiomC{$\Gamma \vdash e_2:\tau$}
\BinaryInfC{$\Gamma \vdash e_1\ e_2 : \tau'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash e:\tau$}
\UnaryInfC{$\Gamma \vdash \Lambda(\alpha:k).e : \forall(\alpha:k).\tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\forall(\alpha:k).\tau'$}
\AxiomC{$\Gamma \vdash \tau:k$}
\BinaryInfC{$\Gamma \vdash e[\tau] : [\tau/\alpha]\tau'$}
\end{prooftree}
\]</p>
<p>Note that these rules aren't sufficient -- If we have \(f : \forall(\beta:*
\rightarrow *). \beta\ \texttt{int} \rightarrow \texttt{unit}\), we'd want to
have \(f[\lambda(\alpha:*).\alpha]\ 12 : \texttt{unit}\). However, by the above
rules, we type \(f[\lambda(\alpha:*):\alpha]\) at \(((\lambda \alpha.\alpha)
\ \texttt{int}) \rightarrow \texttt{unit}\), not \(\texttt{int} \rightarrow
\texttt{unit}\).</p>
<p>To remedy this, we need some way to express that \((\lambda \alpha.\alpha)
\ \texttt{int}\) is equivalent to \(\texttt{int}\), which we will accomplish by
defining a new judgment \(\Gamma \vdash c \equiv c' : k\), then adding to rules
1.2 the equivalence rule</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\tau$}
\AxiomC{$\Gamma \vdash \tau \equiv \tau':*$}
\BinaryInfC{$\Gamma \vdash e:\tau'$}
\end{prooftree}
\]</p>
<p><strong>Rules 1.3 (Constructor Equivalence):</strong> \(\Gamma \vdash c \equiv c':k\)</p>
<p><em>Equivalence</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k$}
\UnaryInfC{$\Gamma \vdash c \equiv c:k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c':k$}
\UnaryInfC{$\Gamma \vdash c' \equiv c:k$} \qquad
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_2:k$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_3:k$}
\BinaryInfC{$\Gamma \vdash c_1 \equiv c_3:k$}
\end{prooftree}
\]</p>
<p><em>Compatibility</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \equiv \tau_1' : *$}
\AxiomC{$\Gamma \vdash \tau_2 \equiv \tau_2' : *$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \equiv
\tau_1' \rightarrow \tau_2' : *$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \equiv \tau' : *$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \equiv \forall(\alpha:k).\tau':*$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c \equiv c':k'$}
\UnaryInfC{$\Gamma \vdash \lambda(\alpha:k).c \equiv \lambda(\alpha:k).c':
k \rightarrow k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c_1 \equiv c_1':k \rightarrow k'$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2':k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \equiv c_1'\ c_2':k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1':k_1$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2':k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \equiv
\langle c_1', c_2' \rangle : k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \equiv \pi_1c' : k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \equiv \pi_2c' : k_2$}
\end{prooftree}
\]</p>
<p><em>Reduction/beta</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:k'$}
\AxiomC{$\Gamma \vdash c':k$}
\BinaryInfC{$\Gamma \vdash (\lambda (\alpha:k).c)\ c' \equiv [c'/\alpha]c:k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\UnaryInfC{$\Gamma \vdash \pi_1\langle c_1, c_2\rangle \equiv c_1:k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2\langle c_1, c_2\rangle \equiv c_2:k_2$}
\end{prooftree}
\]</p>
<p><em>Extensionality/eta</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k_1 \rightarrow k_2$}
\AxiomC{$\Gamma \vdash c':k_1 \rightarrow k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha \equiv c'\ \alpha:k_2$}
\TrinaryInfC{$\Gamma \vdash c \equiv c' : k_1 \rightarrow k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1 c \equiv \pi_1 c':k_1$}
\AxiomC{$\Gamma \vdash \pi_2 c \equiv \pi_2 c':k_2$}
\BinaryInfC{$\Gamma \vdash c \equiv c':k_1 \times k_2$}
\end{prooftree}
\]</p>
<p>Note that in many cases, we enforce that some
constructors are types (kind \(*\)) -- we certainly can't have tuples or lambda
abstractions underlying a \(\forall\) type, for example.</p>
<p>The first set of rules, labeled &quot;equivalence&quot;, ensure that this is indeed an
equivalence/congruence relation.</p>
<p>The beta rules are the interesting ones. With them, we can prove (assuming
we've defined the relevant primitive types):</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \texttt{int}:*$}
\AxiomC{}
\UnaryInfC{$\beta:* \vdash \beta:*$}
\BinaryInfC{$\vdash (\lambda \beta.\beta)\ \texttt{int} \equiv\texttt{int}:*$}
\UnaryInfC{$\vdash (\lambda \beta.\beta)\ \texttt{int} \rightarrow
\texttt{unit} \equiv \texttt{int} \rightarrow \texttt{unit}:*$}
\end{prooftree}
\]</p>
<p>Finally, the extensionality rules allow us to evaluate &quot;underneath&quot; tuples and
lambda abstractions. You might think of these as conducting an &quot;experiment&quot; to
see whether the relevant constructors behave equivalently.</p>
<h2><a class="header" href="#remarks" id="remarks">Remarks</a></h2>
<ul>
<li>
<p>As it turns out, in this system, the \(:k\) annotation on equivalence is
unnecessary, as they are uniquely determined by the kinding rules.</p>
<p><strong>Theorem (Regularity)</strong>.</p>
<ol>
<li>If \(\vdash \Gamma\ ok\) and \(\Gamma \vdash e:\tau\), then \(\Gamma \vdash \tau:*\).</li>
<li>If \(\vdash \Gamma\ ok\) and \(\Gamma \vdash c \equiv c':k\), then \(\Gamma \vdash
c:k\) and \(\Gamma \vdash c':k\)</li>
</ol>
<p><em>Proof</em>.</p>
<ol>
<li>By induction over the judgment \(\Gamma \vdash e:\tau\).</li>
<li>By induction over the judgment \(\Gamma \vdash c \equiv c':k\).</li>
</ol>
<p>\(\square\)</p>
<p>where \(\vdash \Gamma\ ok\) is a judgment ensuring that all types in \(\Gamma\)
are well-formed.</p>
<p><strong>Rules 1.4 (Well-formed contexts)</strong>: \(\vdash \Gamma\ ok\)
\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \cdot\ ok$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma\ ok$}
\AxiomC{$\Gamma \vdash \tau:*$}
\BinaryInfC{$\vdash \Gamma, x:\tau\ ok$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\vdash \Gamma\ ok$}
\UnaryInfC{$\vdash \Gamma, \alpha:k\ ok$}
\end{prooftree}
\]</p>
</li>
</ul>
<h1><a class="header" href="#typechecking-f_omega" id="typechecking-f_omega">Typechecking \(F_\omega^{++}\)</a></h1>
<p>Algorithmically typechecking \(F_\omega\) is more complex. The existence of the
reflexive, symmetric and transitive equivalence rules may make proof search more
difficult. For example, if the current proof obligations are to show that
\(c_1 \equiv c_3 : k\), to use the transitivity rule we would need to guess a
\(c_2\) to pass through.</p>
<p>The type system of \(F_\omega\) is equivalent to the simply-typed lambda calculus,
so one approach for checking whether two constructors are equivalent is to
beta-normalize them, then compare them structurally. This would work, but does
not generalize well to later systems.</p>
<p>The immediately relevant judgments are:</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Rightarrow \overset{-}{k}\)</td><td>kind synthesis</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Leftarrow \overset{+}{k}\)</td><td>kind checking</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{e} \Rightarrow \overset{-}{\tau}\)</td><td>type sythesis</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{e} \Leftarrow \overset{+}{\tau}\)</td><td>type checking</td></tr>
</tbody></table>
<p>The \(+\) and \(-\) symbols denote modality (\(+\) is input and \(-\) is output), but
are not otherwise necessary. These
judgments form a standard bidirectional typechecking (and kind-checking) algorithm.</p>
<p>In the process, we will also need four more judgments:</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Leftrightarrow \overset{+}{c'} : \overset{+}{k}\)</td><td>algorithmic equivalence</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \leftrightarrow \overset{+}{c'} : \overset{-}{k}\)</td><td>structural equivalence</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Downarrow \overset{-}{c'}\)</td><td>weak-head normalization</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \rightsquigarrow \overset{-}{c'}\)</td><td>weak-head reduction</td></tr>
</tbody></table>
<h2><a class="header" href="#inference-rules" id="inference-rules">Inference Rules</a></h2>
<p><strong>Rules 1.5 (Type synthesis):</strong> \(\Gamma \vdash e \Rightarrow \tau\)</p>
<p>\[\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x \Rightarrow \tau$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau \Leftarrow *$}
\AxiomC{$\Gamma, x:\tau \vdash e \Rightarrow \tau'$}
\BinaryInfC{$\Gamma \vdash \lambda(x:\tau).e \Rightarrow \tau \rightarrow \tau'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1 \Rightarrow \tau$}
\AxiomC{$\Gamma \vdash \tau \Downarrow \tau_1 \rightarrow \tau_2$}
\AxiomC{$\Gamma \vdash e_1 \Leftarrow \tau_1$}
\TrinaryInfC{$\Gamma \vdash e_1\ e_2 \Rightarrow \tau_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash e \Rightarrow \tau$}
\UnaryInfC{$\Gamma \vdash \Lambda(\alpha:k).e \Rightarrow \forall(\alpha:k).\tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e \Rightarrow \tau$}
\AxiomC{$\Gamma \vdash \tau \Downarrow \forall(\alpha:k).\tau'$}
\AxiomC{$\Gamma \vdash c \Leftarrow k$}
\TrinaryInfC{$\Gamma \vdash e[c] \Rightarrow [c/\alpha]\tau'$}
\end{prooftree}
\]</p>
<p>Unlike in 15-317, we mandate the type annotation on the parameter of a lambda,
so we can synthesize its type. In the last two rules, we cannot &quot;pattern match&quot;
on the synthesized type of the candidate function, because it could have beta
redexes. Instead, we normalize it.</p>
<p><strong>Rules 1.6 (Type checking):</strong> \(\Gamma \vdash e \Leftarrow \tau\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e \Rightarrow \tau'$}
\AxiomC{$\Gamma \vdash \tau \Leftrightarrow \tau' : *$}
\BinaryInfC{$\Gamma \vdash e \Leftarrow \tau$}
\end{prooftree}
\]</p>
<p>We don't yet have a way to construct an invalid kind, so we don't need to
ensure that kinds are well-formed (<em>yet</em>).</p>
<p><strong>Rules 1.7 (Kind synthesis):</strong> \(\Gamma \vdash c \Rightarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \Rightarrow k$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \Leftarrow *$}
\AxiomC{$\Gamma \vdash \tau_2 \Leftarrow *$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \Rightarrow *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \Leftarrow *$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \Rightarrow *$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c \Rightarrow k'$}
\UnaryInfC{$\Gamma \vdash \lambda(\alpha:k).c \Rightarrow k \rightarrow k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow k_1 \rightarrow k_2$}
\AxiomC{$\Gamma \vdash c_2 \Rightarrow k_1$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \Rightarrow k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow k_1$}
\AxiomC{$\Gamma \vdash c_2 \Rightarrow k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \Rightarrow k_1 \times k_2$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \Rightarrow k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \Rightarrow k_2$}
\end{prooftree}
\]</p>
<p><strong>Rules 1.8 (Kind checking):</strong> \(\Gamma \vdash c \Leftarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k'$}
\AxiomC{$k = k'$}
\BinaryInfC{$\Gamma \vdash c \Leftarrow k$}
\end{prooftree}
\]</p>
<p>The rule for kind checking could be written more compactly to use the same
variable \(k\) in both premise and conclusion (thus dropping the \(k = k'\) premise),
but we write it this way so it can generalize to later calculi (particularly
the notion of equality).</p>
<p>When writing the equivalence rules, we will use extensionality to recurse on
the <em>kind</em> via the appropriate projections or function application. What we
<em>don't</em> do is normalize both types and check equivalence, because this doesn't
generalize to the calculus of singleton kinds.</p>
<p><strong>Rules 1.9 (Algorithmic Equivalence)</strong>: \(\Gamma \vdash c \Leftrightarrow c' : k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c\ \alpha \Leftrightarrow c'\ \alpha:k_2$}
\UnaryInfC{$\Gamma \vdash c \Leftrightarrow c' : k_1 \rightarrow k_2$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma\vdash \pi_1c \Leftrightarrow \pi_1c' : k_1$}
\AxiomC{$\Gamma\vdash \pi_2c \Leftrightarrow \pi_2c' : k_2$}
\BinaryInfC{$\Gamma \vdash c \Leftrightarrow c':k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Downarrow c_1'$}
\AxiomC{$\Gamma \vdash c_2 \Downarrow c_2'$}
\AxiomC{$\Gamma \vdash c_1' \leftrightarrow c_2':*$}
\TrinaryInfC{$\Gamma \vdash c_1 \Leftrightarrow c_2:*$}
\end{prooftree}
\]</p>
<p>Normalization only happens once we reach the kind \(*\).</p>
<p>A normal form is one that has contracted all \(\beta\)-redices. We will instead
use <em>weak-head</em> normal form, in which an arrow constructor or a universal
constructor is at the outermost level (we don't recursively normalize).</p>
<p><strong>Rules 1.10 (Weak-head normalization):</strong> \(\Gamma \vdash c \Downarrow c'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \rightsquigarrow c'$}
\AxiomC{$\Gamma \vdash c' \Downarrow c''$}
\BinaryInfC{$\Gamma \vdash c \Downarrow c''$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \not\rightsquigarrow$}
\UnaryInfC{$\Gamma \vdash c \Downarrow c$}
\end{prooftree}
\]</p>
<p>Although we could formally defined the judgment \(\Gamma \vdash c
\not\rightsquigarrow\), we will choose not to for brevity. This could be
implemented in ML by raising an exception or returning a <code>NONE</code> option if none
of the stepping rules apply.</p>
<p><strong>Rules 1.11 (Weak-head reduction):</strong> \(\Gamma \vdash c \rightsquigarrow c'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash
(\lambda (\alpha:k).c)\ c' \rightsquigarrow [c'/\alpha]c$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_1'$}
\UnaryInfC{$\Gamma \vdash c_1\ c_2 \rightsquigarrow c_1'\ c_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_1 \langle c_1, c_2 \rangle \rightsquigarrow c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_2 \langle c_1, c_2 \rangle \rightsquigarrow c_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_1'$}
\UnaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \rightsquigarrow
\langle c_1', c_2 \rangle$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_2 \rightsquigarrow c_2'$}
\UnaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \rightsquigarrow
\langle c_1, c_2' \rangle$}
\end{prooftree}
\]</p>
<p>When weak-head normalizing, we only reduce under application and projection.
This way, when we encounter types such as \(((\lambda \alpha.\alpha)
\ (\lambda \alpha.\alpha)) c\), we can reduce them.</p>
<p>A weak-head normalized constructor can only take certain forms. Those which
could be normalized further but are not we'll call &quot;paths&quot;.</p>
<p>\[
\begin{aligned}
\text{whnf}\ \hat{c} &amp;:= c \rightarrow c \mid \forall(\alpha:k).c \mid p \\
\text{path}\ p &amp;:= \alpha \mid p\ c \mid \pi_1p \mid \pi_2p
\end{aligned}
\]</p>
<p>By the extensionality rules, we ensure that we reach kind \(*\), so this grammar
is exhaustive.
Paths are obviously
neutral, and whnf terms are almost neutral, except that the subterms (bodies
of universal type and arrow) may contain redices.</p>
<p><strong>Rules 1.12 (Structural Equivalence):</strong> \(\Gamma \vdash \hat{c_1}
\rightarrow \hat{c_2}: k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Leftrightarrow c_1': *$}
\AxiomC{$\Gamma \vdash c_2 \Leftrightarrow c_2': *$}
\BinaryInfC{$\Gamma \vdash c_1 \rightarrow c_2 \leftrightarrow
c_1' \rightarrow c_2'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \Leftrightarrow \tau': *$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \leftrightarrow
\forall(\alpha:k).\tau':*$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \leftrightarrow \alpha : k$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \leftrightarrow c_1' : k_1 \rightarrow k_2$}
\AxiomC{$\Gamma \vdash c_2 \Leftrightarrow c_2' : k_1$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \leftrightarrow c_1'\ c_2' : k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \leftrightarrow c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \leftrightarrow \pi_1c':k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \leftrightarrow c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \leftrightarrow \pi_2c':k_2$}
\end{prooftree}
\]</p>
<p>Algorithmic structural equivalence is not too surprising. The kind is
synthesized as an output, which allows it to be put back in as an input to the
algorithmic equivalence judgment.</p>
<h1><a class="header" href="#the-singleton-kind-calculus" id="the-singleton-kind-calculus">The Singleton Kind Calculus</a></h1>
<p>The next type theory we'll be exploring is the calculus of singleton kinds.
This is necessary to represent type-fixed signatures, like</p>
<pre><code class="language-ocaml">sig
  type t = int
  type u
  val a : t
end
</code></pre>
<p>How do we kind this? We can't kind the <code>t</code> tycon at \(*\), because that would
allow nonconformant structures (say, those assigning <code>t</code> to <code>string</code>) to
ascribe.</p>
<p>The answer is to add a new kind constructor <code>S(c)</code> of <em>singleton kinds</em>, kinds
with only one inhabitant. Set-theoretically, <code>S(c)</code> represents the singleton
set \({c}\), but that's about where the similarities end.</p>
<p>It turns out that this simple construct (and its intuitive properties) require
<em>a lot</em> more power in its machinery.</p>
<h1><a class="header" href="#singleton-kinds-declaratively" id="singleton-kinds-declaratively">Singleton kinds, declaratively</a></h1>
<p>The singleton kind calculus relevant to us is syntactically an extension of
\(F_\omega\) (plus products), with identical constructors and terms. The kinds,
of course, are extended with the \(S(c)\) singleton kind. But to fully represent
modules, we need more power.</p>
<p>Consider the signature</p>
<pre><code class="language-ocaml">sig
  type t
  type u = t * int
end
</code></pre>
<p>Intuitively, we might write this kind as \(* \times S(t \times \texttt{int})\),
but this isn't well-formed (the type variable \(t\) is not in scope). This
necessitates the use of <em>dependent kinds</em>, \(\Sigma\)- and \(\Pi\)-kinds. These
subsume normal arrow and (non-dependent) product kinds, giving us</p>
<p>\[\require{bussproofs}k := * \mid S(c) \mid \Sigma(\alpha:k).k \mid \Pi(\alpha:k).k\]</p>
<p>Of course, we will still use \(k \rightarrow k'\) and \(k \times k'\) as shorthand
for \(\Pi(\alpha:k).k'\) and \(\Sigma(\alpha:k).k'\) respectively if \(k\) is not
free in \(k'\).</p>
<p>The judgments we will use are</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\Gamma \vdash k:\text{kind}\)</td><td>Kind validity</td></tr>
<tr><td>\(\Gamma \vdash k \equiv k' : \text{kind}\)</td><td>Kind equivalence</td></tr>
<tr><td>\(\Gamma \vdash k \le k'\)</td><td>Subkinding</td></tr>
<tr><td>\(\Gamma \vdash c: k\)</td><td>Kinding</td></tr>
<tr><td>\(\Gamma \vdash c \equiv c' : k\)</td><td>Constructor equivalence</td></tr>
<tr><td>\(\Gamma \vdash e : \tau\)</td><td>Typing (same as \(F_\omega\))</td></tr>
<tr><td>\(\phantom{\Gamma} \vdash \Gamma\ ok\)</td><td>Context well-formedness</td></tr>
</tbody></table>
<p>The addition of singleton kinds necessitates subkinding to handle cases like
<code>int</code>, which has kind \(*\) but <em>also</em> kind \(S(\texttt{int})\).</p>
<p><strong>Rules 2.1 (Kind validity):</strong> \(\Gamma \vdash k:\text{kind}\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * : \text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:*$}
\UnaryInfC{$\Gamma \vdash S(c): \text{kind}$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1:\text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2:\text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1:\text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_2:\text{kind}$}
\end{prooftree}
\]</p>
<p><strong>Rules 2.2 (Kind equivalence):</strong> \(\Gamma \vdash k \equiv k' : \text{kind}\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * \equiv * : \text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : *$}
\UnaryInfC{$\Gamma \vdash S(c) \equiv S(c') :\text{kind}$}
\end{prooftree}
\]</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \equiv k_1' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \equiv k_2' : \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2 \equiv \Pi(\alpha:k_1').k_2'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \equiv k_1' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \equiv k_2' : \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_2 \equiv \Sigma(\alpha:k_1').k_2'$}
\end{prooftree}
\]</p>
<p>Before moving onward, we'll need some more machinery. By the above rules, we
can only define singleton kinds for <em>types</em> (constructors kinded at \(*\)). As
a typechecking mechanism, this is important, lest someone write <code>type t = list</code>. When declaring our whole system, however, this can be inconvenient.
Let us define the
<em>generalized singleton</em> \(S(c:k)\) be defined as follows:</p>
<p>\[
\begin{aligned}
S(c:*) &amp;\triangleq S(c) \\
S(c:\Pi(\alpha:k_1).k_2) &amp;\triangleq \Pi(\alpha:k_1).S(c\ \alpha : k_2) \\
S(c:\Sigma(\alpha:k_1).k_2) &amp;\triangleq
S(\pi_1c : k_1) \times S(\pi_2c:[\pi_1c/\alpha]k_2) \\
S(c:S(c')) &amp;\triangleq S(c)
\end{aligned}
\]</p>
<p>Note that the \(\Sigma\) clause could be more concisely written as
\(\Sigma(\alpha:S(\pi_1c:k_1)).S(\pi_2c:k_2)\), but we choose to expand it out
for clarity. Ideally, this definition should fit to the following condition
(written as a derived rule):</p>
<p>\[
\begin{prooftree}
\alwaysDashedLine
\AxiomC{$\Gamma \vdash c:k$}
\AxiomC{$\vdash \Gamma\ ok$}
\BinaryInfC{$\Gamma \vdash S(c:k)\ ok$}
\end{prooftree}
\]</p>
<p>which it does.</p>
<p>Why is all this necessary? Previously, when checking constructor equivalence,
neither \(\Gamma\) nor \(k\) were used. But what about in this system?</p>
<p>\[
\lambda (\alpha:*) . \alpha \overset{?}{=} \lambda (\alpha:*) . \texttt{int}
\]</p>
<p>Before, we would say that this is &quot;obviously false&quot;. Calling one on a type that
is not <code>int</code> demonstrates this. But now, with
subkinding, we might say that</p>
<p>\[\cdot \vdash \lambda (\alpha:*) . \alpha : S(\texttt{int}) \rightarrow *\]</p>
<p>because \(S(\texttt{int}) \le *\). But then, these two lambdas should be
equivalent, because if \(\alpha : S(\texttt{int})\), then \(\alpha\) must be
(equivalent to) \(\texttt{int}\) itself! So clearly the kind we are checking at
matters.</p>
<p>Similarly, we need the context as well. Consider</p>
<p>\[
\beta (\lambda(\alpha:*).\alpha) \overset{?}{=} \beta(\lambda(\alpha:*).\texttt{int})
\]</p>
<p>Now, the kind of \(\beta\) fixes the kinds of the lambdas (which, as we saw
above, matters).</p>
<p><strong>Rules 2.3 (Subkinding):</strong> \(\Gamma \vdash k \le k'\)</p>
<p><em>Preorder</em>:
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \equiv k':\text{kind}$}
\UnaryInfC{$\Gamma \vdash k \le k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \le k_2$}
\AxiomC{$\Gamma \vdash k_2 \le k_3$}
\BinaryInfC{$\Gamma \vdash k_1 \le k_3$}
\end{prooftree}
\]</p>
<p><em>Other</em>:
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:*$}
\UnaryInfC{$\Gamma \vdash S(c) \le *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : *$}
\RightLabel{$*$}
\UnaryInfC{$\Gamma \vdash S(c) \le S(c')$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1' \le k_1$}
\AxiomC{$\Gamma, \alpha:k_1' \vdash k_2 \le k_2'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 : \text{kind}$}
\TrinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2 \le \Pi(\alpha:k_1').k_2'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \le k_1'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \le k_2'$}
\AxiomC{$\Gamma, \alpha:k_1' \vdash k_2' : \text{kind}$}
\TrinaryInfC{$\Gamma\vdash\Sigma(\alpha:k_1).k_2\le\Sigma(\alpha:k_1').k_2'$}
\end{prooftree}
\]</p>
<p>The starred rule is actually unnecessary, as it falls out from the symmetry
rule.</p>
<p>The rule for \(\Pi\) types flips the direction of the input kind, as functions
are known to be contravariant. When checking the dependent parts of \(\Pi\) and
\(\Sigma\), it is important that our context holds that \(\alpha\) is the <em>larger</em>
kind, as it will work for both comparands. Finally, we must check that certain
subkinds are well-formed, as this won't necessarily fall out from proving other
premises.</p>
<p><strong>Rules 2.4.1 (Kinding, incomplete):</strong> \(\Gamma \vdash c:k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:k'$}
\AxiomC{$\Gamma \vdash k:\text{kind}$}
\BinaryInfC{$\Gamma \vdash \lambda(\alpha:k).c : \Pi(\alpha:k).k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:\Pi(\alpha:k).k'$}
\AxiomC{$\Gamma \vdash c_2:k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2:[c_2/\alpha]k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c : k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c : [\pi_1c/\alpha]k_2$}
\end{prooftree}
\]</p>
<p>The major missing rule is the one kinding type-level tuples. There is one
obvious candidate:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:[c_1/\alpha]k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\TrinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle:\Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<p>There is also the rule for non-dependent tuples:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle : k_1 \times k_2$}
\end{prooftree}
\]</p>
<p>which clearly falls out from the first rule. It turns out, however, that these
two formulations are actually <em>equivalent</em> (under subsumption). Suppose we are
given \(\Gamma \vdash c_1:k_1\), \(\Gamma \vdash c_2:[c_1/alpha]k_2\) and that the
kinds are well-formed. Then</p>
<ul>
<li>We have \(\Gamma \vdash c_1:S(c_1:k_1)\) by how we defined generalized singletons</li>
<li>\(\Gamma \vdash \langle c_1, c_2 \rangle : S(c_1:k_1) \times [c_1/\alpha]k_2\)
by the non-dependent product rule.</li>
<li>\(\alpha\) is not free in \([c_1/\alpha]k_2\), so \(\Gamma, \alpha:S(c_1:k_1) \vdash
[c_1/\alpha]k_2 \le k_2\).</li>
<li>So \(\Gamma \vdash S(c_1:k_1) \times [c_1/\alpha]k_2 \le \Sigma(\alpha:k_1).k_2\).</li>
<li>Then by subsumption, \(\Gamma \vdash \langle c_1, c_2 \rangle : \Sigma(\alpha:k_1).
k_2\).  It turns out that using the non-dependent product rule is ultimately much
simpler, so we will use it over the dependent version.</li>
</ul>
<p>We complete rules 2.4 (for now) with singletons, arrows and \(\forall\):</p>
<p><strong>Rules 2.4.2 (Kinding continued, still incomplete):</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle : k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c': *$}
\UnaryInfC{$\Gamma \vdash c : S(c')$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1:*$}
\AxiomC{$\Gamma \vdash \tau_2:*$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2:*$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k:\text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash \tau:*$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau : *$}
\end{prooftree}
\]</p>
<p>The rule for singletons should be unsurprising, and the rules for arrow and
\(\forall\) types are unchanged from system \(F_\omega\).</p>
<p>At last, then, we come to constructor equivalence. The general theme will be
to use dependent versions of the rules we had before.</p>
<p><strong>Rules 2.5 (Constructor equivalence):</strong> \(\Gamma \vdash c \equiv c'\)</p>
<p><em>Equivalence:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k$}
\UnaryInfC{$\Gamma \vdash c \equiv c:k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : k$}
\UnaryInfC{$\Gamma \vdash c' \equiv c : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_2:k$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_3:k$}
\BinaryInfC{$\Gamma \vdash c_1 \equiv c_3:k$}
\end{prooftree}
\]</p>
<p><em>Compatibility:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \equiv k_1' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c \equiv c':k_2$}
\BinaryInfC{$\Gamma \vdash \lambda(\alpha:k_1).c \equiv \lambda(\alpha:k_1').c':
\Pi(\alpha:k_1).k_2$}
\end{prooftree} \quad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1' : \Pi(\alpha:k_1).k_2$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2' : k_2$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \equiv c_1'\ c_2' : [c_2/\alpha]k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1' : k_1$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2' : [c/\alpha]k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \equiv \langle c_1', c_2' \rangle
: \Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \equiv \pi_1c':k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \equiv \pi_2c':[\pi_1c/\alpha]k_2$}
\end{prooftree}
\]</p>
<p><em>Types constructors:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1' : *$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2' : *$}
\BinaryInfC{$\Gamma \vdash c_1\rightarrow c_2 \equiv c_1' \rightarrow c_2':*$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \equiv k' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash c \equiv c' : *$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).c\equiv\forall(\alpha:k').c':*$}
\end{prooftree}
\]</p>
<p><em>Beta-reduction:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash (\lambda(\alpha:k_1).c_2)\ c_1
\equiv [c_1/\alpha]c_2 : [c_1/\alpha]k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 : k_1$}
\AxiomC{$\Gamma \vdash c_2 : k_2$}
\BinaryInfC{$\Gamma \vdash \pi_1 \langle c_1, c_2 \rangle \equiv c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 : k_1$}
\AxiomC{$\Gamma \vdash c_2 : k_2$}
\BinaryInfC{$\Gamma \vdash \pi_2 \langle c_1, c_2 \rangle \equiv c_2$}
\end{prooftree}
\]</p>
<p><em>Extensionality:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2'$}
\AxiomC{$\Gamma \vdash c':\Pi(\alpha:k_1).k_2''$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha \equiv c'\ \alpha : k_2$}
\TrinaryInfC{$\Gamma \vdash c \equiv c' : \Pi(\alpha:k_1).k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1c \equiv \pi_1c' : k_1$}
\AxiomC{$\Gamma \vdash \pi_2c \equiv \pi_2c' : [\pi_1c/\alpha]k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\TrinaryInfC{$\Gamma \vdash c \equiv c' : \Sigma(\alpha:k_2)$}
\end{prooftree}
\]</p>
<p>Finally, we may choose to include a singleton rule:</p>
<p>\[
\begin{prooftree}
\alwaysDashedLine
\AxiomC{$\Gamma \vdash c:S(c')$}
\UnaryInfC{$\Gamma \vdash c \equiv c':S(c')$}
\end{prooftree}
\]</p>
<p>but it's unnecessary, as it arises inversion of the singleton rule from 2.4.2.</p>
<p>It turns out, however, that our formulation of constructor kinding isn't quite
complete. Consider the following situation.</p>
<p>Recall that \(S(c:\Pi(\alpha:k_1).k_2 = \Pi(\alpha:k_1).S(c\ \alpha : k_2)\).
Then consider the type constructor \(\lambda(\alpha:*).\texttt{int}\):</p>
<p>\[
\begin{aligned}
\lambda(\alpha:*).\texttt{int} &amp;: S(\lambda(\alpha:*).\texttt{int}:* \rightarrow *)
\\
&amp;= \Pi(\alpha:*).S((\lambda(\alpha:*).\texttt{int})\ \alpha : *) \\
&amp;= \Pi(\alpha:*).S((\lambda(\alpha:*).\texttt{int})\ \alpha) \\
&amp;= \Pi(\alpha:*).S(\texttt{int})
\end{aligned}
\]</p>
<p>(where the \(=\) above are kind equality)</p>
<p>By this, we should be able to derive \(\lambda(\alpha:*).\texttt{int}:
\Pi(\alpha:*).S(\texttt{int})\). This can be done easily:</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\alpha:* \vdash \texttt{int} : S(\texttt{int})$}
\UnaryInfC{$\cdot \vdash \lambda(\alpha:\texttt{int}).\texttt{int}
: \Pi(\alpha:*).S(\texttt{int})$}
\end{prooftree}
\]</p>
<p>which should follow from our existing rules.</p>
<p>However, this doesn't generalize. Namely, we should be able to show that, if
\(\beta:S(* \rightarrow *)\), then \(\beta:\Pi(\alpha:*).S(\beta\ \alpha)\).
As our rules currently are, however, we can't do this -- our rules currently
only allow type lambdas and beta- or pi-redexes to have \(\Pi\)-types, and the
singular variable \(\beta\) is neither. A similar issue arises with product kinds.
We can resolves this by giving up the
structural-only property of the constructor kinding rules and adding
extensionality there as well:</p>
<p><strong>Rules 2.4.3 (Kinding finalized)</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha:k_2$}
\BinaryInfC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1c:k_1$}
\AxiomC{$\Gamma \vdash \pi_2c:[\pi_1c/\alpha]k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\TrinaryInfC{$\Gamma \vdash c:\Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#remarks-1" id="remarks-1">Remarks</a></h2>
<ul>
<li>I'm a bit sketched on how the proof of non-dependent products implying dependent
products works. The moral reason is that the dependent argument must have a
fully instantiated kind, so it doesn't matter whether the actual sum kind
is dependent, but the subtyping via the generalized singleton doesn't quite
make sense to me. Maybe I'll do the full proof out later.</li>
</ul>
<h1><a class="header" href="#typechecking-the-skc" id="typechecking-the-skc">Typechecking the SKC</a></h1>
<p>Typechecking will act similarly to what we've done before; many of these
judgements should look familiar (for ease of typesetting I'm choosing to use
superscripts for modes instead of writing it on top of the character from here
onwards).</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\Gamma^+ \vdash k^+ \Leftarrow \text{kind}\)</td><td>Kind validity</td></tr>
<tr><td>\(\Gamma^+ \vdash k^+ \Leftrightarrow k'^+ : \text{kind}\)</td><td>Kind equivalence</td></tr>
<tr><td>\(\Gamma^+ \vdash k^+ \unlhd k'^+\)</td><td>Subkinding</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Rightarrow k^-\)</td><td>Kind synthesis</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Leftarrow k^+\)</td><td>Kind checking</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \uparrow k^- \)</td><td>Natural kind</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Leftrightarrow c'^+ : k^+\)</td><td>Algorithmic equivalence</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \leftrightarrow c'^+ : k^-\)</td><td>Structural path equivalence</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \rightsquigarrow c'^-\)</td><td>Weak-head reduction</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Downarrow c'^-\)</td><td>Weak-head normalization</td></tr>
<tr><td>\(\Gamma^+ \vdash e^+ \Rightarrow \tau^-\)</td><td>Type synthesis</td></tr>
<tr><td>\(\Gamma^+ \vdash e^+ \Leftarrow \tau^+\)</td><td>Type checking</td></tr>
</tbody></table>
<p>As our term and constructor language is entirely unchanged from \(F_\omega\), we
can import the type checking/synthesis rules nearly wholesale. The only change
is that we now need to check that the kind introduced by a \(\forall\) introduction
is well-formed, via adding a kind validity premise:</p>
<p>\[\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash e \Rightarrow \tau$}
\BinaryInfC{$\Gamma \vdash \Lambda(\alpha:k).e \Rightarrow \forall(\alpha:k).\tau$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#kinds" id="kinds">Kinds</a></h2>
<p>Next, we introduce the idea of a <em>principal kind</em>. In the presence of subkinding,
it may be possible infer many non-equivalent kinds for a given constructor, so we
want to produce the one that is &quot;most specific&quot;. A kind \(k\) is principal for a
type constructor \(c\) in context \(\Gamma\) if:</p>
<ul>
<li>\(\Gamma \vdash c:k\)</li>
<li>For all kinds \(k'\), if \(\Gamma \vdash c:k'\), then \(\Gamma \vdash k \le k'\).</li>
</ul>
<p>For example, if \(\alpha\) has kind \(*\), then its principal kind is \(S(\alpha)\).
This is where higher order singletons become see their main use -- if \(c:k\),
then the principal kind of \(c\) is \(S(c:k)\).</p>
<p><strong>Rules 2.6 (Kind validity):</strong> \(\Gamma \vdash k \Leftarrow \text{kind}\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * \Leftarrow \text{kind}$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Leftarrow *$}
\UnaryInfC{$\Gamma \vdash S(c) \Leftarrow \text{kind}$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \Leftarrow \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_1 \Leftarrow \text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \Leftarrow \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_1 \Leftarrow \text{kind}$}
\end{prooftree}
\]</p>
<p>Should be largely unsurprising.</p>
<p><strong>Rules 2.7 (Kind synthesis):</strong> \(\Gamma \vdash c \Rightarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \Rightarrow S(\alpha:k)$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \Leftarrow *$}
\AxiomC{$\Gamma \vdash \tau_2 \Leftarrow *$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \Rightarrow
S(\tau_1 \rightarrow \tau_2)$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \Leftarrow *$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \Rightarrow S(\forall(\alpha:k).\tau)$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k\vdash c \Rightarrow k'$}
\BinaryInfC{$\Gamma \vdash \lambda(\alpha:k).c \Rightarrow \Pi(\alpha:k).k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow k_1$}
\AxiomC{$\Gamma \vdash c_2 \Rightarrow k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle \Rightarrow k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \Rightarrow k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \Rightarrow [\pi_1c/\alpha]k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow \Pi(\alpha:k).k'$}
\AxiomC{$\Gamma \vdash c_2 \Leftarrow k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2: [c_2/\alpha]k$}
\end{prooftree}
\]</p>
<p>Recall that the formation rules for dependent and non-dependent tuples are actually
equivalent, so we take the simpler one.</p>
<p>Kind checking only has one rule, which details subsumption.</p>
<p><strong>Rules 2.8 (Kind checking):</strong> \(\Gamma \vdash c \Leftarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k'$}
\AxiomC{$\Gamma \vdash k' \unlhd k$}
\BinaryInfC{$\Gamma \vdash c \Leftarrow k$}
\end{prooftree}
\]</p>
<p><strong>Rules 2.9 (Subkinding):</strong> \(\Gamma \vdash k \unlhd k'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * \unlhd *$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash S(c) \unlhd *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Leftrightarrow c' :*$}
\UnaryInfC{$\Gamma \vdash S(c) \unlhd S(c')$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1' \unlhd k_1$}
\AxiomC{$\Gamma \alpha:k_1' \vdash k_2' \unlhd k_2$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2 \unlhd \Pi(\alpha:k_1').k_2'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \unlhd k_1'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \unlhd k_2'$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_2 \unlhd \Sigma(\alpha:k_1').k_2'$}
\end{prooftree}
\]</p>
<p>Once again, in the rules for \(\Pi\)- and \(\Sigma\)-kinds, the kind of the type
variable is set to be that of the superkind, as it will be valid in both
of the dependent kinds.</p>
<p><strong>Rules 2.10 (Algorithmic equivalence):</strong> \(\Gamma \vdash c \Leftrightarrow c':k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash c \Leftrightarrow c' : S(c'')$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Downarrow c_1'$}
\AxiomC{$\Gamma \vdash c_2 \Downarrow c_2'$}
\AxiomC{$\Gamma \vdash c_1' \leftrightarrow c_2' : k$}
\TrinaryInfC{$\Gamma \vdash c_1 \Leftrightarrow c_2 : *$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha \Leftrightarrow c'\ \alpha:k_2$}
\UnaryInfC{$\Gamma \vdash c \Leftrightarrow c' : \Pi(\alpha:k_1).k_2$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1c \Leftrightarrow \pi_1c' : k_1$}
\AxiomC{$\Gamma \vdash \pi_2c \Leftrightarrow \pi_2c' : [\pi_1c/\alpha]k_2$}
\BinaryInfC{$\Gamma \vdash c \Leftrightarrow c' : \Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<p>The singleton rule follows via regularity (soundness). In the rule at kind
\(*\), we can ignore the kinds returned from \(\leftrightarrow\) for the same
reason -- if, in the resultant code, we ever query \(\Gamma \vdash c_1 \equiv
c_2 : k\), we'd better have that \(\Gamma \vdash c_1:k\) and \(\Gamma \vdash c_2:k\).</p>
<h2><a class="header" href="#natural-kinds" id="natural-kinds">Natural Kinds</a></h2>
<p>Structural equality is about the same as \(F_\omega\), with one major caveat.
Consider the following:</p>
<p>\[\beta:*, \alpha:S(\beta) \vdash \alpha \Leftrightarrow \beta : *\]</p>
<p>This should certainly be derivable by the definition of the singleton kinds.
However, we need some extra machinery to be able to express this -- \(\alpha\)
is <em>certainly</em> not structurally equal to \(\beta\), as they are different
free variables. We will define
the &quot;natural kind&quot; of a constructor to be the &quot;obvious&quot; result, without trying
to be clever or more specific. But first, weak head reduction:</p>
<p><strong>Rules 2.11 (Weak head reduction and normalization)</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_2$}
\AxiomC{$\Gamma \vdash c_2 \Downarrow c_3$}
\BinaryInfC{$\Gamma \vdash c_1 \Downarrow c_3$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \not\rightsquigarrow$}
\UnaryInfC{$\Gamma \vdash c \Downarrow c$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow S(c)$}
\UnaryInfC{$\Gamma \vdash p \rightsquigarrow c$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_1'$}
\UnaryInfC{$\Gamma \vdash c_1\ c_2 \rightsquigarrow c_1'\ c_2$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \rightsquigarrow c'$}
\UnaryInfC{$\Gamma \vdash \pi_1c \rightsquigarrow \pi_1c'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \rightsquigarrow c'$}
\UnaryInfC{$\Gamma \vdash \pi_2c \rightsquigarrow \pi_2c'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash (\lambda(\alpha:k).c_1)\ c_2 \rightsquigarrow
[c_2/\alpha]c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_1 \langle c_1, c_2 \rangle \rightsquigarrow c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_2 \langle c_1, c_2 \rangle \rightsquigarrow c_2$}
\end{prooftree}
\]</p>
<p>As before, we will restrict structural equality and natural kinding to only
apply to those tycons that are weak head normalized. Recall that such constructors
are either lambdas, \(\forall\)-types, or paths. We don't want to natural kind
lambdas or \(\forall\), since they will give us \(*\), which isn't what we're
looking for with these rules. As such, we have used \(p\) to represent path
constructors.</p>
<p><strong>Rules 2.12 (Natural Kind):</strong> \(\Gamma \vdash p \uparrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \uparrow k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow \Pi(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash p\ c \uparrow [c/\alpha]k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1p \uparrow k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2p \uparrow [\pi_1p/\alpha]k_2$}
\end{prooftree}
\]</p>
<p>Note that we don't bother looking up a natural kind for \(c_1\ c_2\), because it
will never be a singleton, so why bother?</p>
<p>Now, we can derive the earlier example. Letting \(\Gamma = \beta:*, \alpha:
S(\beta)\), we have</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma(\alpha) = S(\beta)$}
\UnaryInfC{$\Gamma \vdash \alpha \uparrow S(\beta)$}
\UnaryInfC{$\Gamma \vdash \alpha \rightsquigarrow \beta$}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \beta \not\rightsquigarrow$}
\BinaryInfC{$\Gamma \vdash \alpha \Downarrow \beta$}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \beta \not\rightsquigarrow$}
\UnaryInfC{$\Gamma \vdash \beta \Downarrow \beta$}
\AxiomC{}
\UnaryInfC{$\Gamma(\beta) = *$}
\UnaryInfC{$\Gamma \vdash \beta \leftrightarrow \beta:*$}
\TrinaryInfC{$\Gamma \vdash \alpha \Leftrightarrow \beta : *$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#structural-equivalence-at-last" id="structural-equivalence-at-last">Structural Equivalence, at last</a></h2>
<p>For completeness, the structural equality rules, which are largely unchanged
from \(F_\omega\):</p>
<p><strong>Rules 2.13 (Structural equality):</strong> \(\Gamma \vdash p \leftrightarrow p'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \leftrightarrow \alpha : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \Leftrightarrow \tau_1':*$}
\AxiomC{$\Gamma \vdash \tau_2 \Leftrightarrow \tau_2':*$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \leftrightarrow
\tau_1' \rightarrow \tau_2' : *$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftrightarrow k' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash c \Leftrightarrow c' : *$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).c \leftrightarrow
\forall(\alpha:k').c'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \leftrightarrow p' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1p \leftrightarrow \pi_1p'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \leftrightarrow p' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2p \leftrightarrow \pi_2p'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash p_1 \leftrightarrow p_2:\Pi(\alpha:k_1).k_2$}
\AxiomC{$\Gamma \vdash c_1 \Leftrightarrow c_2:k_1$}
\BinaryInfC{$\Gamma \vdash p_1\ c_1 \leftrightarrow p_1\ c_2:[c_1/\alpha]k_2$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#remarks-2" id="remarks-2">Remarks</a></h2>
<ul>
<li>Professor Crary glossed over or entirely skipped some of the rules mentioned
here, particularly kind equivalence (which made the homework extra fun...).
I have included those rules from
Nick Roberts' notes for the sake of completeness.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
