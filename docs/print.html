<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Higher-Order Typed Compilation</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A transcription of my lecture notes from 15-417">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded affix "><a href="index.html">Intro</a></li><li class="expanded "><a href="fw/index.html"><strong aria-hidden="true">1.</strong> Unit 1: System Fw</a></li><li><ol class="section"><li class="expanded "><a href="fw/system-f.html"><strong aria-hidden="true">1.1.</strong> Review: System F</a></li><li class="expanded "><a href="fw/declarative.html"><strong aria-hidden="true">1.2.</strong> Declarative system</a></li><li class="expanded "><a href="fw/algorithmic.html"><strong aria-hidden="true">1.3.</strong> Typechecking</a></li></ol></li><li class="expanded "><a href="singleton/index.html"><strong aria-hidden="true">2.</strong> Unit 2: Singleton kinds</a></li><li><ol class="section"><li class="expanded "><a href="singleton/declarative.html"><strong aria-hidden="true">2.1.</strong> Declarative system</a></li><li class="expanded "><a href="singleton/algorithmic.html"><strong aria-hidden="true">2.2.</strong> Algorithmic rules</a></li></ol></li><li class="expanded "><a href="binding/index.html"><strong aria-hidden="true">3.</strong> Aside: Binding</a></li><li class="expanded "><a href="cps/index.html"><strong aria-hidden="true">4.</strong> Unit 3: Continuation Passing Style</a></li><li><ol class="section"><li class="expanded "><a href="cps/tdt.html"><strong aria-hidden="true">4.1.</strong> Primer: Type-directed translation</a></li><li class="expanded "><a href="cps/basic.html"><strong aria-hidden="true">4.2.</strong> Introduction to CPS</a></li><li class="expanded "><a href="cps/direct.html"><strong aria-hidden="true">4.3.</strong> Call by Value CPS</a></li><li class="expanded "><a href="cps/cbncallcc.html"><strong aria-hidden="true">4.4.</strong> Other evaluation strategies</a></li><li class="expanded "><a href="cps/exceptions.html"><strong aria-hidden="true">4.5.</strong> Exceptions</a></li><li class="expanded "><a href="cps/other.html"><strong aria-hidden="true">4.6.</strong> Closing Notes</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Higher-Order Typed Compilation</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#15-417-hot-compilation-spring-2020" id="15-417-hot-compilation-spring-2020">15-417 HOT Compilation, Spring 2020</a></h1>
<ul>
<li>Professor: Karl Crary</li>
<li>Scribe: Cameron Wong</li>
<li>Carnegie Mellon University</li>
</ul>
<p>Joining a grand tradition, I'm going to attempt and inevitably give up at
typesetting the notes for this class.</p>
<p>Material is grouped by subject and is roughly ordered by when we covered them
in class. There is no separation by individual lectures. The order of material
in a given subsection is, roughly following class presentation order, but may
be reordered according to what I personally find to be clearer.</p>
<p>These are somewhat inspired by Nick Roberts' attempt, and a lot of the early
material is... well, not lifted, but definitely influenced by his explanations.</p>
<p>I will do my best to keep my personal comments restricted to the remarks. Any
mistakes are mine. These notes will include no more SML code than was presented
in lecture.</p>
<p>This document is intended to be read as an <code>mdbook</code>, which, at the time of this
writing, can be viewed <a href="https://hotc.camdar.io/">here</a>.</p>
<p><a href="https://github.com/CT075/hotc">source</a></p>
<h2><a class="header" href="#structure-of-the-compiler" id="structure-of-the-compiler">Structure of the Compiler</a></h2>
<p>The compiler developed by this class will follow the following progression:</p>
<svg class="bob" font-family="arial" font-size="14" height="720" width="264" xmlns="http://www.w3.org/2000/svg">
<defs>
<marker id="triangle" markerHeight="8" markerWidth="8" orient="auto" refX="4" refY="2" viewBox="0 0 8 4">
<polygon class="fg_fill" points="0,0 0,4 8,2 0,0"/>
</marker>
<marker id="clear_triangle" markerHeight="10" markerWidth="10" orient="auto" refX="1" refY="7" viewBox="0 0 20 14">
<polygon class="bg_fill" points="2,2 2,12 18,7 2,2"/>
</marker>
<marker id="circle" markerHeight="5" markerWidth="5" orient="auto" refX="10" refY="10" viewBox="0 0 20 20">
<circle class="fg_fill" cx="10" cy="10" r="8"/>
</marker>
<marker id="square" markerHeight="5" markerWidth="5" orient="auto" refX="10" refY="10" viewBox="0 0 20 20">
<rect class="fg_fill" height="20" width="20" x="0" y="0"/>
</marker>
<marker id="open_circle" markerHeight="10" markerWidth="10" orient="auto" refX="10" refY="10" viewBox="0 0 20 20">
<circle class="bg_fill" cx="10" cy="10" r="4"/>
</marker>
<marker id="big_open_circle" markerHeight="20" markerWidth="20" orient="auto" refX="20" refY="20" viewBox="0 0 40 40">
<circle class="bg_fill" cx="20" cy="20" r="6"/>
</marker>
</defs>
<style type="text/css">
rect.backdrop {
    fill: white;
}
text{
    fill: black;
}
circle {
    fill: none;
    stroke: black;
    stroke-width: 2;
}
line {
    stroke: black;
    stroke-width: 2;
    stroke-opacity: 1;
    fill-opacity: 1;
    stroke-linecap: round;
    stroke-linejoin: miter;
}
path {
    fill: none;
    stroke: black;
    stroke-width: 2;
    stroke-opacity: 1;
    fill-opacity: 1;
    stroke-linecap: round;
    stroke-linejoin: miter;
}
line.dashed {
    stroke-dasharray: 5;
}
.fg_fill {
    fill: black;
}
.bg_fill {
    fill: white;
    stroke: black;
    stroke-width: 2;
}
tspan.head{
    fill: none;
    stroke: none;
}
</style>
<rect class="backdrop" height="720" width="264" x="0" y="0"/>
<g>
<line x1="4" x2="4" y1="8" y2="40"/>
<line x1="4" x2="100" y1="8" y2="8"/>
<line x1="4" x2="52" y1="40" y2="40"/>
<line x1="52" x2="52" y1="40" y2="104"/>
<line x1="52" x2="100" y1="40" y2="40"/>
<line x1="52" x2="100" y1="104" y2="104"/>
<line x1="100" x2="100" y1="8" y2="40"/>
<line x1="100" x2="100" y1="104" y2="136"/>
</g>
<g>
<line x1="4" x2="4" y1="104" y2="136"/>
<line x1="4" x2="52" y1="104" y2="104"/>
<line x1="4" x2="52" y1="136" y2="136"/>
<line x1="52" x2="52" y1="136" y2="200"/>
<line x1="52" x2="100" y1="136" y2="136"/>
<line x1="52" x2="100" y1="200" y2="200"/>
<line x1="100" x2="100" y1="200" y2="232"/>
</g>
<g>
<line x1="4" x2="4" y1="200" y2="232"/>
<line x1="4" x2="52" y1="200" y2="200"/>
<line x1="4" x2="52" y1="232" y2="232"/>
<line x1="52" x2="52" y1="232" y2="296"/>
<line x1="52" x2="100" y1="232" y2="232"/>
<line x1="52" x2="100" y1="296" y2="296"/>
<line x1="100" x2="100" y1="296" y2="328"/>
</g>
<g>
<line x1="4" x2="4" y1="296" y2="328"/>
<line x1="4" x2="52" y1="296" y2="296"/>
<line x1="4" x2="52" y1="328" y2="328"/>
<line x1="52" x2="52" y1="328" y2="392"/>
<line x1="52" x2="100" y1="328" y2="328"/>
<line x1="52" x2="108" y1="392" y2="392"/>
<line x1="108" x2="108" y1="392" y2="424"/>
</g>
<g>
<line x1="4" x2="4" y1="392" y2="424"/>
<line x1="4" x2="52" y1="392" y2="392"/>
<line x1="4" x2="52" y1="424" y2="424"/>
<line x1="52" x2="52" y1="424" y2="488"/>
<line x1="52" x2="108" y1="424" y2="424"/>
<line x1="52" x2="100" y1="488" y2="488"/>
<line x1="100" x2="100" y1="488" y2="520"/>
</g>
<g>
<line x1="4" x2="4" y1="488" y2="520"/>
<line x1="4" x2="52" y1="488" y2="488"/>
<line x1="4" x2="52" y1="520" y2="520"/>
<line x1="52" x2="52" y1="520" y2="584"/>
<line x1="52" x2="100" y1="520" y2="520"/>
<line x1="52" x2="100" y1="584" y2="584"/>
<line x1="100" x2="100" y1="584" y2="616"/>
</g>
<g>
<line x1="4" x2="4" y1="584" y2="616"/>
<line x1="4" x2="52" y1="584" y2="584"/>
<line x1="4" x2="52" y1="616" y2="616"/>
<line x1="52" x2="52" y1="616" y2="680"/>
<line x1="52" x2="100" y1="616" y2="616"/>
<line x1="52" x2="100" y1="680" y2="680"/>
<line x1="100" x2="100" y1="680" y2="712"/>
</g>
<g>
<line x1="4" x2="4" y1="680" y2="712"/>
<line x1="4" x2="52" y1="680" y2="680"/>
<line x1="4" x2="100" y1="712" y2="712"/>
</g>
<g>
<text x="25" y="124">
IL-Module
</text>
</g>
<g>
<text x="25" y="220">
IL-Direct
</text>
</g>
<g>
<text x="25" y="412">
IL-Closure
</text>
</g>
<g>
<text x="25" y="508">
IL-Hoist
</text>
</g>
<g>
<text x="25" y="604">
IL-Alloc
</text>
</g>
<g>
<text x="33" y="316">
IL-CPS
</text>
</g>
<g>
<text x="41" y="28">
SML
</text>
</g>
<g>
<text x="49" y="700">
C
</text>
</g>
<g>
<text x="65" y="76">
Elaboration
</text>
</g>
<g>
<text x="65" y="172">
Phase-splitting
</text>
</g>
<g>
<text x="65" y="268">
CPS
</text>
</g>
<g>
<text x="65" y="364">
Closure Conversion
</text>
</g>
<g>
<text x="65" y="460">
Hoisting
</text>
</g>
<g>
<text x="65" y="556">
Allocation/Type Erasure
</text>
</g>
<g>
<text x="65" y="652">
Code
</text>
</g>
<g>
<text x="97" y="268">
Conversion
</text>
</g>
<g>
<text x="105" y="652">
generation
</text>
</g>
<g>
<text x="113" y="28">
(AST)
</text>
</g>
</svg>
<p>where each <code>IL-</code> language is some intermediate form. Until IL-Alloc, each
intermediary language is also typed, which will aid in ensuring that the passes
are well-formed.</p>
<p>It is possible to preserve types all the way down, foregoing the type erasure
leading into IL-Alloc. Such compilers often have an &quot;hourglass effect&quot;, in
which the intermediary typesystems get increasingly simple down to a point, at
which they become more complex again. Consider a typed memory representation of
the sum type \(A+B\), for example. We have to store a tag (for which variant)
along with the object itself, giving us a layout of</p>
<svg class="bob" font-family="arial" font-size="14" height="48" width="104" xmlns="http://www.w3.org/2000/svg">
<defs>
<marker id="triangle" markerHeight="8" markerWidth="8" orient="auto" refX="4" refY="2" viewBox="0 0 8 4">
<polygon class="fg_fill" points="0,0 0,4 8,2 0,0"/>
</marker>
<marker id="clear_triangle" markerHeight="10" markerWidth="10" orient="auto" refX="1" refY="7" viewBox="0 0 20 14">
<polygon class="bg_fill" points="2,2 2,12 18,7 2,2"/>
</marker>
<marker id="circle" markerHeight="5" markerWidth="5" orient="auto" refX="10" refY="10" viewBox="0 0 20 20">
<circle class="fg_fill" cx="10" cy="10" r="8"/>
</marker>
<marker id="square" markerHeight="5" markerWidth="5" orient="auto" refX="10" refY="10" viewBox="0 0 20 20">
<rect class="fg_fill" height="20" width="20" x="0" y="0"/>
</marker>
<marker id="open_circle" markerHeight="10" markerWidth="10" orient="auto" refX="10" refY="10" viewBox="0 0 20 20">
<circle class="bg_fill" cx="10" cy="10" r="4"/>
</marker>
<marker id="big_open_circle" markerHeight="20" markerWidth="20" orient="auto" refX="20" refY="20" viewBox="0 0 40 40">
<circle class="bg_fill" cx="20" cy="20" r="6"/>
</marker>
</defs>
<style type="text/css">
rect.backdrop {
    fill: white;
}
text{
    fill: black;
}
circle {
    fill: none;
    stroke: black;
    stroke-width: 2;
}
line {
    stroke: black;
    stroke-width: 2;
    stroke-opacity: 1;
    fill-opacity: 1;
    stroke-linecap: round;
    stroke-linejoin: miter;
}
path {
    fill: none;
    stroke: black;
    stroke-width: 2;
    stroke-opacity: 1;
    fill-opacity: 1;
    stroke-linecap: round;
    stroke-linejoin: miter;
}
line.dashed {
    stroke-dasharray: 5;
}
.fg_fill {
    fill: black;
}
.bg_fill {
    fill: white;
    stroke: black;
    stroke-width: 2;
}
tspan.head{
    fill: none;
    stroke: none;
}
</style>
<rect class="backdrop" height="48" width="104" x="0" y="0"/>
<g>
<line x1="4" x2="4" y1="8" y2="40"/>
<line x1="4" x2="52" y1="8" y2="8"/>
<line x1="4" x2="52" y1="40" y2="40"/>
<line x1="52" x2="52" y1="8" y2="40"/>
<line x1="52" x2="100" y1="8" y2="8"/>
<line x1="52" x2="100" y1="40" y2="40"/>
<line x1="100" x2="100" y1="8" y2="40"/>
</g>
<g>
<text x="17" y="28">
tag
</text>
</g>
<g>
<text x="65" y="28">
obj
</text>
</g>
</svg>
<p>Our typesystem must be powerful enough to express these layouts
accurately, hence the extra complexity. This may continue all the
way down to, say, a typed assembly language. In this class, however, we only
have enough time to cover up to IL-Alloc, and will thus generate C from there.</p>
<h1><a class="header" href="#system-fw" id="system-fw">System Fw</a></h1>
<p>System \(F_\omega\) is a system of higher-kinded types and type-constructors. It
is relevant to compiling SML in the way that it relates to the module system.
If we extend the kind system of &quot;true&quot; \(F_\omega\) with product kinds, we might
represent the module signature</p>
<pre><code class="language-ocaml">sig
  type t
  type 'a u
end
</code></pre>
<p>as the kind \(* \times (* \rightarrow *)\), and so on. This even
extends to functors that act on modules via type-level lambdas.</p>
<h1><a class="header" href="#system-f" id="system-f">System F</a></h1>
<p>As a warmup to \(F_\omega\), a brief review of the rules for
System F.</p>
<p>\[\require{bussproofs}
\begin{aligned}
\tau &amp;:= \alpha \mid \tau \rightarrow \tau \mid \forall \alpha . \tau \\
e &amp;:= x \mid \lambda (x:\tau).e \mid e\ e \mid \Lambda \alpha.e \mid e[\tau]
\end{aligned}
\]</p>
<p>When typechecking System F, we use two judgments, \(\Gamma \vdash x:
\tau\) and \(\Gamma \vdash \tau:*\)<sup class="footnote-reference"><a href="#1">1</a></sup>. The latter is often written
\(\Gamma \vdash \tau\ type\), but we will use this notation so it becomes
familiar for the future.</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha)= * $}
\UnaryInfC{$\Gamma \vdash \alpha: * $}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1: * $}
\AxiomC{$\Gamma \vdash \tau_2: * $}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2: * $}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:* \vdash \tau : *$}
\UnaryInfC{$\Gamma \vdash \forall \alpha.\tau : *$}
\end{prooftree}
\]</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x : \tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, x:\tau_1 \vdash e:\tau_2$}
\UnaryInfC{$\Gamma \vdash \lambda (x:\tau_1) . e : \tau_1 \rightarrow \tau_2$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:* \vdash e:\tau$}
\UnaryInfC{$\Gamma \vdash \Lambda \alpha. e : \forall \alpha . \tau$}
\end{prooftree}
\]</p>
<p>The defining feature of System F is the \(\Lambda \alpha.e\) syntax form, with
its corresponding \(\forall \alpha.e\) type, the so-called &quot;type-lambdas&quot; or
&quot;polymorphic values&quot;. Just as value lambdas annotate their argument, we may
also choose to do so with type lambdas, as \(\Lambda (\alpha : *).e\). Then the
rule for typing big lambda expressions becomes</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:* \vdash e:\tau$}
\UnaryInfC{$\Gamma \vdash \Lambda (\alpha:*). e : \forall \alpha . \tau$}
\end{prooftree}
\]</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The kind of base types is officially \(T\) for \(type\), but I'm going to follow the Haskell convention of writing it as \(*\).</p>
</div>
<h1><a class="header" href="#system-f_omega" id="system-f_omega">System F\(_\omega^{++}\)</a></h1>
<p>\(F_\omega\) is the calculus of higher-kinded type constructors, combining two
axes of the lambda cube (polymorphism and type operators).</p>
<p>The syntax of \(F_\omega\) is an extension of \(F\). First, we need to
adjust our syntax to use type constructors (or just &quot;constructors&quot;) instead of
just types. By convention, we will use \(\tau\) to denote a nullary constructor,
a constructor kinded at \(*\) (see below).</p>
<p>\[\require{bussproofs}
c, \tau := \alpha \mid c \rightarrow c \mid \forall (\alpha : k).c
\mid \lambda (\alpha : k) .c \mid c\ c
\]</p>
<p>where \(\alpha\) is a type variable used in quantification and type abstraction.</p>
<p>Next, we will add \(k\), to denote kinds:</p>
<p>\[
k := * \mid k \rightarrow k
\]</p>
<p>We also need terms to inhabit those types:</p>
<p>\[
e := x \mid \lambda (x:\tau).e \mid \Lambda(\alpha:k).e \mid e[\tau]
\]</p>
<p>Our context, \(\Gamma\), may contain judgments about types and terms.</p>
<p>\[
\Gamma := \cdot \mid \Gamma, x:\tau \mid \Gamma : \alpha:k
\]</p>
<p>You may also see the kinding judgment written as \(\alpha :: k\).</p>
<p>Finally, as noted earlier, we will need to extend \(F_\omega\) with primitive
product kinds to handle ML modules (hence the ++ in \(F_\omega^{++}\)):</p>
<p>\[
\begin{aligned}
k &amp;:= \dots \mid k \times k \\
c &amp;:= \dots \mid \langle c, c \rangle \mid \pi_1 c \mid \pi_2 c
\end{aligned}
\]</p>
<p>This language is defined statically as follows:</p>
<p><strong>Rules 1.1 (Kinding)</strong>: \(\Gamma \vdash c:k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:*$}
\AxiomC{$\Gamma \vdash c_2:*$}
\BinaryInfC{$\Gamma \vdash c_1 \rightarrow c_2 : *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:*$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).c:*$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k \rightarrow k'$}
\AxiomC{$\Gamma \vdash c_2:k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 : k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:k'$}
\UnaryInfC{$\Gamma \vdash \lambda (\alpha:k).c : k \rightarrow k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle : k_1 \times k_2$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1 c : k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2 c : k_2$}
\end{prooftree}
\]</p>
<p><strong>Rules 1.2 (Typing)</strong>: \(\Gamma \vdash e:\tau\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, x:\tau \vdash e:\tau'$}
\AxiomC{$\Gamma \vdash \tau:*$}
\BinaryInfC{$\Gamma \vdash \lambda(x:\tau).e : \tau \rightarrow \tau'$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \vdash e_1:\tau \rightarrow \tau'$}
\AxiomC{$\Gamma \vdash e_2:\tau$}
\BinaryInfC{$\Gamma \vdash e_1\ e_2 : \tau'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash e:\tau$}
\UnaryInfC{$\Gamma \vdash \Lambda(\alpha:k).e : \forall(\alpha:k).\tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\forall(\alpha:k).\tau'$}
\AxiomC{$\Gamma \vdash \tau:k$}
\BinaryInfC{$\Gamma \vdash e[\tau] : [\tau/\alpha]\tau'$}
\end{prooftree}
\]</p>
<p>Note that these rules aren't sufficient -- If we have \(f : \forall(\beta:*
\rightarrow *). \beta\ \texttt{int} \rightarrow \texttt{unit}\), we'd want to
have \(f[\lambda(\alpha:*).\alpha]\ 12 : \texttt{unit}\). However, by the above
rules, we type \(f[\lambda(\alpha:*):\alpha]\) at \(((\lambda \alpha.\alpha)
\ \texttt{int}) \rightarrow \texttt{unit}\), not \(\texttt{int} \rightarrow
\texttt{unit}\).</p>
<p>To remedy this, we need some way to express that \((\lambda \alpha.\alpha)
\ \texttt{int}\) is equivalent to \(\texttt{int}\), which we will accomplish by
defining a new judgment \(\Gamma \vdash c \equiv c' : k\), then adding to rules
1.2 the equivalence rule</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\tau$}
\AxiomC{$\Gamma \vdash \tau \equiv \tau':*$}
\BinaryInfC{$\Gamma \vdash e:\tau'$}
\end{prooftree}
\]</p>
<p><strong>Rules 1.3 (Constructor Equivalence):</strong> \(\Gamma \vdash c \equiv c':k\)</p>
<p><em>Equivalence</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k$}
\UnaryInfC{$\Gamma \vdash c \equiv c:k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c':k$}
\UnaryInfC{$\Gamma \vdash c' \equiv c:k$} \qquad
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_2:k$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_3:k$}
\BinaryInfC{$\Gamma \vdash c_1 \equiv c_3:k$}
\end{prooftree}
\]</p>
<p><em>Compatibility</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \equiv \tau_1' : *$}
\AxiomC{$\Gamma \vdash \tau_2 \equiv \tau_2' : *$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \equiv
\tau_1' \rightarrow \tau_2' : *$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \equiv \tau' : *$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \equiv \forall(\alpha:k).\tau':*$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c \equiv c':k'$}
\UnaryInfC{$\Gamma \vdash \lambda(\alpha:k).c \equiv \lambda(\alpha:k).c':
k \rightarrow k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c_1 \equiv c_1':k \rightarrow k'$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2':k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \equiv c_1'\ c_2':k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1':k_1$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2':k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \equiv
\langle c_1', c_2' \rangle : k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \equiv \pi_1c' : k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \equiv \pi_2c' : k_2$}
\end{prooftree}
\]</p>
<p><em>Reduction/beta</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:k'$}
\AxiomC{$\Gamma \vdash c':k$}
\BinaryInfC{$\Gamma \vdash (\lambda (\alpha:k).c)\ c' \equiv [c'/\alpha]c:k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\UnaryInfC{$\Gamma \vdash \pi_1\langle c_1, c_2\rangle \equiv c_1:k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2\langle c_1, c_2\rangle \equiv c_2:k_2$}
\end{prooftree}
\]</p>
<p><em>Extensionality/eta</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k_1 \rightarrow k_2$}
\AxiomC{$\Gamma \vdash c':k_1 \rightarrow k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha \equiv c'\ \alpha:k_2$}
\TrinaryInfC{$\Gamma \vdash c \equiv c' : k_1 \rightarrow k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1 c \equiv \pi_1 c':k_1$}
\AxiomC{$\Gamma \vdash \pi_2 c \equiv \pi_2 c':k_2$}
\BinaryInfC{$\Gamma \vdash c \equiv c':k_1 \times k_2$}
\end{prooftree}
\]</p>
<p>Note that in many cases, we enforce that some
constructors are types (kind \(*\)) -- we certainly can't have tuples or lambda
abstractions underlying a \(\forall\) type, for example.</p>
<p>The first set of rules, labeled &quot;equivalence&quot;, ensure that this is indeed an
equivalence/congruence relation.</p>
<p>The beta rules are the interesting ones. With them, we can prove (assuming
we've defined the relevant primitive types):</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \texttt{int}:*$}
\AxiomC{}
\UnaryInfC{$\beta:* \vdash \beta:*$}
\BinaryInfC{$\vdash (\lambda \beta.\beta)\ \texttt{int} \equiv\texttt{int}:*$}
\UnaryInfC{$\vdash (\lambda \beta.\beta)\ \texttt{int} \rightarrow
\texttt{unit} \equiv \texttt{int} \rightarrow \texttt{unit}:*$}
\end{prooftree}
\]</p>
<p>Finally, the extensionality rules allow us to evaluate &quot;underneath&quot; tuples and
lambda abstractions. You might think of these as conducting an &quot;experiment&quot; to
see whether the relevant constructors behave equivalently.</p>
<h2><a class="header" href="#remarks" id="remarks">Remarks</a></h2>
<ul>
<li>
<p>As it turns out, in this system, the \(:k\) annotation on equivalence is
unnecessary, as they are uniquely determined by the kinding rules.</p>
<p><strong>Theorem (Regularity)</strong>.</p>
<ol>
<li>
<p>If \(\vdash \Gamma\ ok\) and \(\Gamma \vdash e:\tau\), then \(\Gamma \vdash \tau:*\).</p>
</li>
<li>
<p>If \(\vdash \Gamma\ ok\) and \(\Gamma \vdash c \equiv c':k\), then \(\Gamma \vdash
c:k\) and \(\Gamma \vdash c':k\)
<em>Proof</em>.</p>
</li>
<li>
<p>By induction over the judgment \(\Gamma \vdash e:\tau\).</p>
</li>
<li>
<p>By induction over the judgment \(\Gamma \vdash c \equiv c':k\).
\(\square\)</p>
</li>
</ol>
<p>where \(\vdash \Gamma\ ok\) is a judgment ensuring that all types in \(\Gamma\)
are well-formed.</p>
<p><strong>Rules 1.4 (Well-formed contexts)</strong>: \(\vdash \Gamma\ ok\)
\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\vdash \cdot\ ok$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma\ ok$}
\AxiomC{$\Gamma \vdash \tau:*$}
\BinaryInfC{$\vdash \Gamma, x:\tau\ ok$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\vdash \Gamma\ ok$}
\UnaryInfC{$\vdash \Gamma, \alpha:k\ ok$}
\end{prooftree}
\]</p>
</li>
</ul>
<h1><a class="header" href="#typechecking-f_omega" id="typechecking-f_omega">Typechecking \(F_\omega^{++}\)</a></h1>
<p>Algorithmically typechecking \(F_\omega\) is more complex. The existence of the
reflexive, symmetric and transitive equivalence rules may make proof search more
difficult. For example, if the current proof obligations are to show that
\(c_1 \equiv c_3 : k\), to use the transitivity rule we would need to guess a
\(c_2\) to pass through.</p>
<p>The type system of \(F_\omega\) is equivalent to the simply-typed lambda calculus,
so one approach for checking whether two constructors are equivalent is to
beta-normalize them, then compare them structurally. This would work, but does
not generalize well to later systems.</p>
<p>The immediately relevant judgments are:</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Rightarrow \overset{-}{k}\)</td><td>kind synthesis</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Leftarrow \overset{+}{k}\)</td><td>kind checking</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{e} \Rightarrow \overset{-}{\tau}\)</td><td>type sythesis</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{e} \Leftarrow \overset{+}{\tau}\)</td><td>type checking</td></tr>
</tbody></table>
<p>The \(+\) and \(-\) symbols denote modality (\(+\) is input and \(-\) is output), but
are not otherwise necessary. These
judgments form a standard bidirectional typechecking (and kind-checking) algorithm.</p>
<p>In the process, we will also need four more judgments:</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Leftrightarrow \overset{+}{c'} : \overset{+}{k}\)</td><td>algorithmic equivalence</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \leftrightarrow \overset{+}{c'} : \overset{-}{k}\)</td><td>structural equivalence</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \Downarrow \overset{-}{c'}\)</td><td>weak-head normalization</td></tr>
<tr><td>\(\overset{+}{\Gamma} \vdash \overset{+}{c} \rightsquigarrow \overset{-}{c'}\)</td><td>weak-head reduction</td></tr>
</tbody></table>
<h2><a class="header" href="#inference-rules" id="inference-rules">Inference Rules</a></h2>
<p><strong>Rules 1.5 (Type synthesis):</strong> \(\Gamma \vdash e \Rightarrow \tau\)</p>
<p>\[\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x \Rightarrow \tau$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau \Leftarrow *$}
\AxiomC{$\Gamma, x:\tau \vdash e \Rightarrow \tau'$}
\BinaryInfC{$\Gamma \vdash \lambda(x:\tau).e \Rightarrow \tau \rightarrow \tau'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1 \Rightarrow \tau$}
\AxiomC{$\Gamma \vdash \tau \Downarrow \tau_1 \rightarrow \tau_2$}
\AxiomC{$\Gamma \vdash e_1 \Leftarrow \tau_1$}
\TrinaryInfC{$\Gamma \vdash e_1\ e_2 \Rightarrow \tau_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash e \Rightarrow \tau$}
\UnaryInfC{$\Gamma \vdash \Lambda(\alpha:k).e \Rightarrow \forall(\alpha:k).\tau$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e \Rightarrow \tau$}
\AxiomC{$\Gamma \vdash \tau \Downarrow \forall(\alpha:k).\tau'$}
\AxiomC{$\Gamma \vdash c \Leftarrow k$}
\TrinaryInfC{$\Gamma \vdash e[c] \Rightarrow [c/\alpha]\tau'$}
\end{prooftree}
\]</p>
<p>Unlike in 15-317, we mandate the type annotation on the parameter of a lambda,
so we can synthesize its type. In the last two rules, we cannot &quot;pattern match&quot;
on the synthesized type of the candidate function, because it could have beta
redexes. Instead, we normalize it.</p>
<p><strong>Rules 1.6 (Type checking):</strong> \(\Gamma \vdash e \Leftarrow \tau\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e \Rightarrow \tau'$}
\AxiomC{$\Gamma \vdash \tau \Leftrightarrow \tau' : *$}
\BinaryInfC{$\Gamma \vdash e \Leftarrow \tau$}
\end{prooftree}
\]</p>
<p>We don't yet have a way to construct an invalid kind, so we don't need to
ensure that kinds are well-formed (<em>yet</em>).</p>
<p><strong>Rules 1.7 (Kind synthesis):</strong> \(\Gamma \vdash c \Rightarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \Rightarrow k$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \Leftarrow *$}
\AxiomC{$\Gamma \vdash \tau_2 \Leftarrow *$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \Rightarrow *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \Leftarrow *$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \Rightarrow *$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c \Rightarrow k'$}
\UnaryInfC{$\Gamma \vdash \lambda(\alpha:k).c \Rightarrow k \rightarrow k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow k_1 \rightarrow k_2$}
\AxiomC{$\Gamma \vdash c_2 \Rightarrow k_1$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \Rightarrow k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow k_1$}
\AxiomC{$\Gamma \vdash c_2 \Rightarrow k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \Rightarrow k_1 \times k_2$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \Rightarrow k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \Rightarrow k_2$}
\end{prooftree}
\]</p>
<p><strong>Rules 1.8 (Kind checking):</strong> \(\Gamma \vdash c \Leftarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k'$}
\AxiomC{$k = k'$}
\BinaryInfC{$\Gamma \vdash c \Leftarrow k$}
\end{prooftree}
\]</p>
<p>The rule for kind checking could be written more compactly to use the same
variable \(k\) in both premise and conclusion (thus dropping the \(k = k'\) premise),
but we write it this way so it can generalize to later calculi (particularly
the notion of equality).</p>
<p>When writing the equivalence rules, we will use extensionality to recurse on
the <em>kind</em> via the appropriate projections or function application. What we
<em>don't</em> do is normalize both types and check equivalence, because this doesn't
generalize to the calculus of singleton kinds.</p>
<p><strong>Rules 1.9 (Algorithmic Equivalence)</strong>: \(\Gamma \vdash c \Leftrightarrow c' : k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c\ \alpha \Leftrightarrow c'\ \alpha:k_2$}
\UnaryInfC{$\Gamma \vdash c \Leftrightarrow c' : k_1 \rightarrow k_2$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma\vdash \pi_1c \Leftrightarrow \pi_1c' : k_1$}
\AxiomC{$\Gamma\vdash \pi_2c \Leftrightarrow \pi_2c' : k_2$}
\BinaryInfC{$\Gamma \vdash c \Leftrightarrow c':k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Downarrow c_1'$}
\AxiomC{$\Gamma \vdash c_2 \Downarrow c_2'$}
\AxiomC{$\Gamma \vdash c_1' \leftrightarrow c_2':*$}
\TrinaryInfC{$\Gamma \vdash c_1 \Leftrightarrow c_2:*$}
\end{prooftree}
\]</p>
<p>Normalization only happens once we reach the kind \(*\).</p>
<p>A normal form is one that has contracted all \(\beta\)-redices. We will instead
use <em>weak-head</em> normal form, in which an arrow constructor or a universal
constructor is at the outermost level (we don't recursively normalize).</p>
<p><strong>Rules 1.10 (Weak-head normalization):</strong> \(\Gamma \vdash c \Downarrow c'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \rightsquigarrow c'$}
\AxiomC{$\Gamma \vdash c' \Downarrow c''$}
\BinaryInfC{$\Gamma \vdash c \Downarrow c''$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \not\rightsquigarrow$}
\UnaryInfC{$\Gamma \vdash c \Downarrow c$}
\end{prooftree}
\]</p>
<p>Although we could formally defined the judgment \(\Gamma \vdash c
\not\rightsquigarrow\), we will choose not to for brevity. This could be
implemented in ML by raising an exception or returning a <code>NONE</code> option if none
of the stepping rules apply.</p>
<p><strong>Rules 1.11 (Weak-head reduction):</strong> \(\Gamma \vdash c \rightsquigarrow c'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash
(\lambda (\alpha:k).c)\ c' \rightsquigarrow [c'/\alpha]c$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_1'$}
\UnaryInfC{$\Gamma \vdash c_1\ c_2 \rightsquigarrow c_1'\ c_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_1 \langle c_1, c_2 \rangle \rightsquigarrow c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_2 \langle c_1, c_2 \rangle \rightsquigarrow c_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_1'$}
\UnaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \rightsquigarrow
\langle c_1', c_2 \rangle$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_2 \rightsquigarrow c_2'$}
\UnaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \rightsquigarrow
\langle c_1, c_2' \rangle$}
\end{prooftree}
\]</p>
<p>When weak-head normalizing, we only reduce under application and projection.
This way, when we encounter types such as \(((\lambda \alpha.\alpha)
\ (\lambda \alpha.\alpha)) c\), we can reduce them.</p>
<p>A weak-head normalized constructor can only take certain forms. Those which
could be normalized further but are not we'll call &quot;paths&quot;.</p>
<p>\[
\begin{aligned}
\text{whnf}\ \hat{c} &amp;:= c \rightarrow c \mid \forall(\alpha:k).c \mid p \\
\text{path}\ p &amp;:= \alpha \mid p\ c \mid \pi_1p \mid \pi_2p
\end{aligned}
\]</p>
<p>By the extensionality rules, we ensure that we reach kind \(*\), so this grammar
is exhaustive.
Paths are obviously
neutral, and whnf terms are almost neutral, except that the subterms (bodies
of universal type and arrow) may contain redices.</p>
<p><strong>Rules 1.12 (Structural Equivalence):</strong> \(\Gamma \vdash \hat{c_1}
\rightarrow \hat{c_2}: k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Leftrightarrow c_1': *$}
\AxiomC{$\Gamma \vdash c_2 \Leftrightarrow c_2': *$}
\BinaryInfC{$\Gamma \vdash c_1 \rightarrow c_2 \leftrightarrow
c_1' \rightarrow c_2'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \Leftrightarrow \tau': *$}
\UnaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \leftrightarrow
\forall(\alpha:k).\tau':*$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \leftrightarrow \alpha : k$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \leftrightarrow c_1' : k_1 \rightarrow k_2$}
\AxiomC{$\Gamma \vdash c_2 \Leftrightarrow c_2' : k_1$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \leftrightarrow c_1'\ c_2' : k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \leftrightarrow c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \leftrightarrow \pi_1c':k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \leftrightarrow c' : k_1 \times k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \leftrightarrow \pi_2c':k_2$}
\end{prooftree}
\]</p>
<p>Algorithmic structural equivalence is not too surprising. The kind is
synthesized as an output, which allows it to be put back in as an input to the
algorithmic equivalence judgment.</p>
<h1><a class="header" href="#the-singleton-kind-calculus" id="the-singleton-kind-calculus">The Singleton Kind Calculus</a></h1>
<p>The next type theory we'll be exploring is the calculus of singleton kinds.
This is necessary to represent type-fixed signatures, like</p>
<pre><code class="language-ocaml">sig
  type t = int
  type u
  val a : t
end
</code></pre>
<p>How do we kind this? We can't kind the <code>t</code> tycon at \(*\), because that would
allow nonconformant structures (say, those assigning <code>t</code> to <code>string</code>) to
ascribe.</p>
<p>The answer is to add a new kind constructor <code>S(c)</code> of <em>singleton kinds</em>, kinds
with only one inhabitant. Set-theoretically, <code>S(c)</code> represents the singleton
set \({c}\), but that's about where the similarities end.</p>
<p>It turns out that this simple construct (and its intuitive properties) require
<em>a lot</em> more power in its machinery.</p>
<h1><a class="header" href="#singleton-kinds-declaratively" id="singleton-kinds-declaratively">Singleton kinds, declaratively</a></h1>
<p>The singleton kind calculus relevant to us is syntactically an extension of
\(F_\omega\) (plus products), with identical constructors and terms. The kinds,
of course, are extended with the \(S(c)\) singleton kind. But to fully represent
modules, we need more power.</p>
<p>Consider the signature</p>
<pre><code class="language-ocaml">sig
  type t
  type u = t * int
end
</code></pre>
<p>Intuitively, we might write this kind as \(* \times S(t \times \texttt{int})\),
but this isn't well-formed (the type variable \(t\) is not in scope). This
necessitates the use of <em>dependent kinds</em>, \(\Sigma\)- and \(\Pi\)-kinds. These
subsume normal arrow and (non-dependent) product kinds, giving us</p>
<p>\[\require{bussproofs}k := * \mid S(c) \mid \Sigma(\alpha:k).k \mid \Pi(\alpha:k).k\]</p>
<p>Of course, we will still use \(k \rightarrow k'\) and \(k \times k'\) as shorthand
for \(\Pi(\alpha:k).k'\) and \(\Sigma(\alpha:k).k'\) respectively if \(k\) is not
free in \(k'\).</p>
<p>The judgments we will use are</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\Gamma \vdash k:\text{kind}\)</td><td>Kind validity</td></tr>
<tr><td>\(\Gamma \vdash k \equiv k' : \text{kind}\)</td><td>Kind equivalence</td></tr>
<tr><td>\(\Gamma \vdash k \le k'\)</td><td>Subkinding</td></tr>
<tr><td>\(\Gamma \vdash c: k\)</td><td>Kinding</td></tr>
<tr><td>\(\Gamma \vdash c \equiv c' : k\)</td><td>Constructor equivalence</td></tr>
<tr><td>\(\Gamma \vdash e : \tau\)</td><td>Typing (same as \(F_\omega\))</td></tr>
<tr><td>\(\phantom{\Gamma} \vdash \Gamma\ ok\)</td><td>Context well-formedness</td></tr>
</tbody></table>
<p>The addition of singleton kinds necessitates subkinding to handle cases like
<code>int</code>, which has kind \(*\) but <em>also</em> kind \(S(\texttt{int})\).</p>
<p><strong>Rules 2.1 (Kind validity):</strong> \(\Gamma \vdash k:\text{kind}\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * : \text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:*$}
\UnaryInfC{$\Gamma \vdash S(c): \text{kind}$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1:\text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2:\text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1:\text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_2:\text{kind}$}
\end{prooftree}
\]</p>
<p><strong>Rules 2.2 (Kind equivalence):</strong> \(\Gamma \vdash k \equiv k' : \text{kind}\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * \equiv * : \text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : *$}
\UnaryInfC{$\Gamma \vdash S(c) \equiv S(c') :\text{kind}$}
\end{prooftree}
\]</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \equiv k_1' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \equiv k_2' : \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2 \equiv \Pi(\alpha:k_1').k_2'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \equiv k_1' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \equiv k_2' : \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_2 \equiv \Sigma(\alpha:k_1').k_2'$}
\end{prooftree}
\]</p>
<p>Before moving onward, we'll need some more machinery. By the above rules, we
can only define singleton kinds for <em>types</em> (constructors kinded at \(*\)). As
a typechecking mechanism, this is important, lest someone write <code>type t = list</code>. When declaring our whole system, however, this can be inconvenient.
Let us define the
<em>generalized singleton</em> \(S(c:k)\) be defined as follows:</p>
<p>\[
\begin{aligned}
S(c:*) &amp;\triangleq S(c) \\
S(c:\Pi(\alpha:k_1).k_2) &amp;\triangleq \Pi(\alpha:k_1).S(c\ \alpha : k_2) \\
S(c:\Sigma(\alpha:k_1).k_2) &amp;\triangleq
S(\pi_1c : k_1) \times S(\pi_2c:[\pi_1c/\alpha]k_2) \\
S(c:S(c')) &amp;\triangleq S(c)
\end{aligned}
\]</p>
<p>Note that the \(\Sigma\) clause could be more concisely written as
\(\Sigma(\alpha:S(\pi_1c:k_1)).S(\pi_2c:k_2)\), but we choose to expand it out
for clarity. Ideally, this definition should fit to the following condition
(written as a derived rule):</p>
<p>\[
\begin{prooftree}
\alwaysDashedLine
\AxiomC{$\Gamma \vdash c:k$}
\AxiomC{$\vdash \Gamma\ ok$}
\BinaryInfC{$\Gamma \vdash S(c:k)\ ok$}
\end{prooftree}
\]</p>
<p>which it does.</p>
<p>Why is all this necessary? Previously, when checking constructor equivalence,
neither \(\Gamma\) nor \(k\) were used. But what about in this system?</p>
<p>\[
\lambda (\alpha:*) . \alpha \overset{?}{=} \lambda (\alpha:*) . \texttt{int}
\]</p>
<p>Before, we would say that this is &quot;obviously false&quot;. Calling one on a type that
is not <code>int</code> demonstrates this. But now, with
subkinding, we might say that</p>
<p>\[\cdot \vdash \lambda (\alpha:*) . \alpha : S(\texttt{int}) \rightarrow *\]</p>
<p>because \(S(\texttt{int}) \le *\). But then, these two lambdas should be
equivalent, because if \(\alpha : S(\texttt{int})\), then \(\alpha\) must be
(equivalent to) \(\texttt{int}\) itself! So clearly the kind we are checking at
matters.</p>
<p>Similarly, we need the context as well. Consider</p>
<p>\[
\beta (\lambda(\alpha:*).\alpha) \overset{?}{=} \beta(\lambda(\alpha:*).\texttt{int})
\]</p>
<p>Now, the kind of \(\beta\) fixes the kinds of the lambdas (which, as we saw
above, matters).</p>
<p><strong>Rules 2.3 (Subkinding):</strong> \(\Gamma \vdash k \le k'\)</p>
<p><em>Preorder</em>:
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \equiv k':\text{kind}$}
\UnaryInfC{$\Gamma \vdash k \le k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \le k_2$}
\AxiomC{$\Gamma \vdash k_2 \le k_3$}
\BinaryInfC{$\Gamma \vdash k_1 \le k_3$}
\end{prooftree}
\]</p>
<p><em>Other</em>:
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:*$}
\UnaryInfC{$\Gamma \vdash S(c) \le *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : *$}
\RightLabel{$*$}
\UnaryInfC{$\Gamma \vdash S(c) \le S(c')$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1' \le k_1$}
\AxiomC{$\Gamma, \alpha:k_1' \vdash k_2 \le k_2'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 : \text{kind}$}
\TrinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2 \le \Pi(\alpha:k_1').k_2'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \le k_1'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \le k_2'$}
\AxiomC{$\Gamma, \alpha:k_1' \vdash k_2' : \text{kind}$}
\TrinaryInfC{$\Gamma\vdash\Sigma(\alpha:k_1).k_2\le\Sigma(\alpha:k_1').k_2'$}
\end{prooftree}
\]</p>
<p>The starred rule is actually unnecessary, as it falls out from the symmetry
rule.</p>
<p>The rule for \(\Pi\) types flips the direction of the input kind, as functions
are known to be contravariant. When checking the dependent parts of \(\Pi\) and
\(\Sigma\), it is important that our context holds that \(\alpha\) is the <em>larger</em>
kind, as it will work for both comparands. Finally, we must check that certain
subkinds are well-formed, as this won't necessarily fall out from proving other
premises.</p>
<p><strong>Rules 2.4.1 (Kinding, incomplete):</strong> \(\Gamma \vdash c:k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k \vdash c:k'$}
\AxiomC{$\Gamma \vdash k:\text{kind}$}
\BinaryInfC{$\Gamma \vdash \lambda(\alpha:k).c : \Pi(\alpha:k).k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:\Pi(\alpha:k).k'$}
\AxiomC{$\Gamma \vdash c_2:k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2:[c_2/\alpha]k'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c : k_1$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c : [\pi_1c/\alpha]k_2$}
\end{prooftree}
\]</p>
<p>The major missing rule is the one kinding type-level tuples. There is one
obvious candidate:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:[c_1/\alpha]k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\TrinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle:\Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<p>There is also the rule for non-dependent tuples:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle : k_1 \times k_2$}
\end{prooftree}
\]</p>
<p>which clearly falls out from the first rule. It turns out, however, that these
two formulations are actually <em>equivalent</em> (under subsumption). Suppose we are
given \(\Gamma \vdash c_1:k_1\), \(\Gamma \vdash c_2:[c_1/alpha]k_2\) and that the
kinds are well-formed. Then</p>
<ul>
<li>We have \(\Gamma \vdash c_1:S(c_1:k_1)\) by how we defined generalized singletons</li>
<li>\(\Gamma \vdash \langle c_1, c_2 \rangle : S(c_1:k_1) \times [c_1/\alpha]k_2\)
by the non-dependent product rule.</li>
<li>\(\alpha\) is not free in \([c_1/\alpha]k_2\), so \(\Gamma, \alpha:S(c_1:k_1) \vdash
[c_1/\alpha]k_2 \le k_2\).</li>
<li>So \(\Gamma \vdash S(c_1:k_1) \times [c_1/\alpha]k_2 \le \Sigma(\alpha:k_1).k_2\).</li>
<li>Then by subsumption, \(\Gamma \vdash \langle c_1, c_2 \rangle : \Sigma(\alpha:k_1).
k_2\).  It turns out that using the non-dependent product rule is ultimately much
simpler, so we will use it over the dependent version.</li>
</ul>
<p>We complete rules 2.4 (for now) with singletons, arrows and \(\forall\):</p>
<p><strong>Rules 2.4.2 (Kinding continued, still incomplete):</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle : k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c': *$}
\UnaryInfC{$\Gamma \vdash c : S(c')$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1:*$}
\AxiomC{$\Gamma \vdash \tau_2:*$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2:*$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k:\text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash \tau:*$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau : *$}
\end{prooftree}
\]</p>
<p>The rule for singletons should be unsurprising, and the rules for arrow and
\(\forall\) types are unchanged from system \(F_\omega\).</p>
<p>At last, then, we come to constructor equivalence. The general theme will be
to use dependent versions of the rules we had before.</p>
<p><strong>Rules 2.5 (Constructor equivalence):</strong> \(\Gamma \vdash c \equiv c'\)</p>
<p><em>Equivalence:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k$}
\UnaryInfC{$\Gamma \vdash c \equiv c:k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : k$}
\UnaryInfC{$\Gamma \vdash c' \equiv c : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_2:k$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_3:k$}
\BinaryInfC{$\Gamma \vdash c_1 \equiv c_3:k$}
\end{prooftree}
\]</p>
<p><em>Compatibility:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \equiv k_1' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c \equiv c':k_2$}
\BinaryInfC{$\Gamma \vdash \lambda(\alpha:k_1).c \equiv \lambda(\alpha:k_1').c':
\Pi(\alpha:k_1).k_2$}
\end{prooftree} \quad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1' : \Pi(\alpha:k_1).k_2$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2' : k_2$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2 \equiv c_1'\ c_2' : [c_2/\alpha]k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1' : k_1$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2' : [c/\alpha]k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1, c_2 \rangle \equiv \langle c_1', c_2' \rangle
: \Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \equiv \pi_1c':k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \equiv c' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \equiv \pi_2c':[\pi_1c/\alpha]k_2$}
\end{prooftree}
\]</p>
<p><em>Types constructors:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \equiv c_1' : *$}
\AxiomC{$\Gamma \vdash c_2 \equiv c_2' : *$}
\BinaryInfC{$\Gamma \vdash c_1\rightarrow c_2 \equiv c_1' \rightarrow c_2':*$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \equiv k' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash c \equiv c' : *$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).c\equiv\forall(\alpha:k').c':*$}
\end{prooftree}
\]</p>
<p><em>Beta-reduction:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1:k_1$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c_2:k_2$}
\BinaryInfC{$\Gamma \vdash (\lambda(\alpha:k_1).c_2)\ c_1
\equiv [c_1/\alpha]c_2 : [c_1/\alpha]k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 : k_1$}
\AxiomC{$\Gamma \vdash c_2 : k_2$}
\BinaryInfC{$\Gamma \vdash \pi_1 \langle c_1, c_2 \rangle \equiv c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 : k_1$}
\AxiomC{$\Gamma \vdash c_2 : k_2$}
\BinaryInfC{$\Gamma \vdash \pi_2 \langle c_1, c_2 \rangle \equiv c_2$}
\end{prooftree}
\]</p>
<p><em>Extensionality:</em>
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2'$}
\AxiomC{$\Gamma \vdash c':\Pi(\alpha:k_1).k_2''$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha \equiv c'\ \alpha : k_2$}
\TrinaryInfC{$\Gamma \vdash c \equiv c' : \Pi(\alpha:k_1).k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1c \equiv \pi_1c' : k_1$}
\AxiomC{$\Gamma \vdash \pi_2c \equiv \pi_2c' : [\pi_1c/\alpha]k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\TrinaryInfC{$\Gamma \vdash c \equiv c' : \Sigma(\alpha:k_2)$}
\end{prooftree}
\]</p>
<p>Finally, we may choose to include a singleton rule:</p>
<p>\[
\begin{prooftree}
\alwaysDashedLine
\AxiomC{$\Gamma \vdash c:S(c')$}
\UnaryInfC{$\Gamma \vdash c \equiv c':S(c')$}
\end{prooftree}
\]</p>
<p>but it's unnecessary, as it arises inversion of the singleton rule from 2.4.2.</p>
<p>It turns out, however, that our formulation of constructor kinding isn't quite
complete. Consider the following situation.</p>
<p>Recall that \(S(c:\Pi(\alpha:k_1).k_2 = \Pi(\alpha:k_1).S(c\ \alpha : k_2)\).
Then consider the type constructor \(\lambda(\alpha:*).\texttt{int}\):</p>
<p>\[
\begin{aligned}
\lambda(\alpha:*).\texttt{int} &amp;: S(\lambda(\alpha:*).\texttt{int}:* \rightarrow *)
\\
&amp;= \Pi(\alpha:*).S((\lambda(\alpha:*).\texttt{int})\ \alpha : *) \\
&amp;= \Pi(\alpha:*).S((\lambda(\alpha:*).\texttt{int})\ \alpha) \\
&amp;= \Pi(\alpha:*).S(\texttt{int})
\end{aligned}
\]</p>
<p>(where the \(=\) above are kind equality)</p>
<p>By this, we should be able to derive \(\lambda(\alpha:*).\texttt{int}:
\Pi(\alpha:*).S(\texttt{int})\). This can be done easily:</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\alpha:* \vdash \texttt{int} : S(\texttt{int})$}
\UnaryInfC{$\cdot \vdash \lambda(\alpha:\texttt{int}).\texttt{int}
: \Pi(\alpha:*).S(\texttt{int})$}
\end{prooftree}
\]</p>
<p>which should follow from our existing rules.</p>
<p>However, this doesn't generalize. Namely, we should be able to show that, if
\(\beta:S(* \rightarrow *)\), then \(\beta:\Pi(\alpha:*).S(\beta\ \alpha)\).
As our rules currently are, however, we can't do this -- our rules currently
only allow type lambdas and beta- or pi-redexes to have \(\Pi\)-types, and the
singular variable \(\beta\) is neither. A similar issue arises with product kinds.
We can resolves this by giving up the
structural-only property of the constructor kinding rules and adding
extensionality there as well:</p>
<p><strong>Rules 2.4.3 (Kinding finalized)</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha:k_2$}
\BinaryInfC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1c:k_1$}
\AxiomC{$\Gamma \vdash \pi_2c:[\pi_1c/\alpha]k_2$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2:\text{kind}$}
\TrinaryInfC{$\Gamma \vdash c:\Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#remarks-1" id="remarks-1">Remarks</a></h2>
<ul>
<li>I'm a bit sketched on how the proof of non-dependent products implying dependent
products works. The moral reason is that the dependent argument must have a
fully instantiated kind, so it doesn't matter whether the actual sum kind
is dependent, but the subtyping via the generalized singleton doesn't quite
make sense to me. Maybe I'll do the full proof out later.</li>
</ul>
<h1><a class="header" href="#typechecking-the-skc" id="typechecking-the-skc">Typechecking the SKC</a></h1>
<p>Typechecking will act similarly to what we've done before; many of these
judgements should look familiar (for ease of typesetting I'm choosing to use
superscripts for modes instead of writing it on top of the character from here
onwards).</p>
<table><thead><tr><th>Judgment</th><th>Meaning</th></tr></thead><tbody>
<tr><td>\(\Gamma^+ \vdash k^+ \Leftarrow \text{kind}\)</td><td>Kind validity</td></tr>
<tr><td>\(\Gamma^+ \vdash k^+ \Leftrightarrow k'^+ : \text{kind}\)</td><td>Kind equivalence</td></tr>
<tr><td>\(\Gamma^+ \vdash k^+ \unlhd k'^+\)</td><td>Subkinding</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Rightarrow k^-\)</td><td>Kind synthesis</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Leftarrow k^+\)</td><td>Kind checking</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \uparrow k^- \)</td><td>Natural kind</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Leftrightarrow c'^+ : k^+\)</td><td>Algorithmic equivalence</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \leftrightarrow c'^+ : k^-\)</td><td>Structural path equivalence</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \rightsquigarrow c'^-\)</td><td>Weak-head reduction</td></tr>
<tr><td>\(\Gamma^+ \vdash c^+ \Downarrow c'^-\)</td><td>Weak-head normalization</td></tr>
<tr><td>\(\Gamma^+ \vdash e^+ \Rightarrow \tau^-\)</td><td>Type synthesis</td></tr>
<tr><td>\(\Gamma^+ \vdash e^+ \Leftarrow \tau^+\)</td><td>Type checking</td></tr>
</tbody></table>
<p>As our term and constructor language is entirely unchanged from \(F_\omega\), we
can import the type checking/synthesis rules nearly wholesale. The only change
is that we now need to check that the kind introduced by a \(\forall\) introduction
is well-formed, via adding a kind validity premise:</p>
<p>\[\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash e \Rightarrow \tau$}
\BinaryInfC{$\Gamma \vdash \Lambda(\alpha:k).e \Rightarrow \forall(\alpha:k).\tau$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#kinds" id="kinds">Kinds</a></h2>
<p>Next, we introduce the idea of a <em>principal kind</em>. In the presence of subkinding,
it may be possible infer many non-equivalent kinds for a given constructor, so we
want to produce the one that is &quot;most specific&quot;. A kind \(k\) is principal for a
type constructor \(c\) in context \(\Gamma\) if:</p>
<ul>
<li>\(\Gamma \vdash c:k\)</li>
<li>For all kinds \(k'\), if \(\Gamma \vdash c:k'\), then \(\Gamma \vdash k \le k'\).</li>
</ul>
<p>For example, if \(\alpha\) has kind \(*\), then its principal kind is \(S(\alpha)\).
This is where higher order singletons become see their main use -- if \(c:k\),
then the principal kind of \(c\) is \(S(c:k)\).</p>
<p><strong>Rules 2.6 (Kind validity):</strong> \(\Gamma \vdash k \Leftarrow \text{kind}\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * \Leftarrow \text{kind}$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Leftarrow *$}
\UnaryInfC{$\Gamma \vdash S(c) \Leftarrow \text{kind}$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \Leftarrow \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_1 \Leftarrow \text{kind}$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \Leftarrow \text{kind}$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_1 \Leftarrow \text{kind}$}
\end{prooftree}
\]</p>
<p>Should be largely unsurprising.</p>
<p><strong>Rules 2.7 (Kind synthesis):</strong> \(\Gamma \vdash c \Rightarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \Rightarrow S(\alpha:k)$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \Leftarrow *$}
\AxiomC{$\Gamma \vdash \tau_2 \Leftarrow *$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \Rightarrow
S(\tau_1 \rightarrow \tau_2)$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash \tau \Leftarrow *$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).\tau \Rightarrow S(\forall(\alpha:k).\tau)$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftarrow \text{kind}$}
\AxiomC{$\Gamma, \alpha:k\vdash c \Rightarrow k'$}
\BinaryInfC{$\Gamma \vdash \lambda(\alpha:k).c \Rightarrow \Pi(\alpha:k).k'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow k_1$}
\AxiomC{$\Gamma \vdash c_2 \Rightarrow k_2$}
\BinaryInfC{$\Gamma \vdash \langle c_1,c_2 \rangle \Rightarrow k_1 \times k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1c \Rightarrow k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2c \Rightarrow [\pi_1c/\alpha]k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Rightarrow \Pi(\alpha:k).k'$}
\AxiomC{$\Gamma \vdash c_2 \Leftarrow k$}
\BinaryInfC{$\Gamma \vdash c_1\ c_2: [c_2/\alpha]k$}
\end{prooftree}
\]</p>
<p>Recall that the formation rules for dependent and non-dependent tuples are actually
equivalent, so we take the simpler one.</p>
<p>Kind checking only has one rule, which details subsumption.</p>
<p><strong>Rules 2.8 (Kind checking):</strong> \(\Gamma \vdash c \Leftarrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Rightarrow k'$}
\AxiomC{$\Gamma \vdash k' \unlhd k$}
\BinaryInfC{$\Gamma \vdash c \Leftarrow k$}
\end{prooftree}
\]</p>
<p><strong>Rules 2.9 (Subkinding):</strong> \(\Gamma \vdash k \unlhd k'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash * \unlhd *$}
\end{prooftree}\qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash S(c) \unlhd *$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \Leftrightarrow c' :*$}
\UnaryInfC{$\Gamma \vdash S(c) \unlhd S(c')$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1' \unlhd k_1$}
\AxiomC{$\Gamma \alpha:k_1' \vdash k_2' \unlhd k_2$}
\BinaryInfC{$\Gamma \vdash \Pi(\alpha:k_1).k_2 \unlhd \Pi(\alpha:k_1').k_2'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash k_1 \unlhd k_1'$}
\AxiomC{$\Gamma, \alpha:k_1 \vdash k_2 \unlhd k_2'$}
\BinaryInfC{$\Gamma \vdash \Sigma(\alpha:k_1).k_2 \unlhd \Sigma(\alpha:k_1').k_2'$}
\end{prooftree}
\]</p>
<p>Once again, in the rules for \(\Pi\)- and \(\Sigma\)-kinds, the kind of the type
variable is set to be that of the superkind, as it will be valid in both
of the dependent kinds.</p>
<p><strong>Rules 2.10 (Algorithmic equivalence):</strong> \(\Gamma \vdash c \Leftrightarrow c':k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash c \Leftrightarrow c' : S(c'')$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \Downarrow c_1'$}
\AxiomC{$\Gamma \vdash c_2 \Downarrow c_2'$}
\AxiomC{$\Gamma \vdash c_1' \leftrightarrow c_2' : k$}
\TrinaryInfC{$\Gamma \vdash c_1 \Leftrightarrow c_2 : *$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha \Leftrightarrow c'\ \alpha:k_2$}
\UnaryInfC{$\Gamma \vdash c \Leftrightarrow c' : \Pi(\alpha:k_1).k_2$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \pi_1c \Leftrightarrow \pi_1c' : k_1$}
\AxiomC{$\Gamma \vdash \pi_2c \Leftrightarrow \pi_2c' : [\pi_1c/\alpha]k_2$}
\BinaryInfC{$\Gamma \vdash c \Leftrightarrow c' : \Sigma(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<p>The singleton rule follows via regularity (soundness). In the rule at kind
\(*\), we can ignore the kinds returned from \(\leftrightarrow\) for the same
reason -- if, in the resultant code, we ever query \(\Gamma \vdash c_1 \equiv
c_2 : k\), we'd better have that \(\Gamma \vdash c_1:k\) and \(\Gamma \vdash c_2:k\).</p>
<h2><a class="header" href="#natural-kinds" id="natural-kinds">Natural Kinds</a></h2>
<p>Structural equality is about the same as \(F_\omega\), with one major caveat.
Consider the following:</p>
<p>\[\beta:*, \alpha:S(\beta) \vdash \alpha \Leftrightarrow \beta : *\]</p>
<p>This should certainly be derivable by the definition of the singleton kinds.
However, we need some extra machinery to be able to express this -- \(\alpha\)
is <em>certainly</em> not structurally equal to \(\beta\), as they are different
free variables. We will define
the &quot;natural kind&quot; of a constructor to be the &quot;obvious&quot; result, without trying
to be clever or more specific. But first, weak head reduction:</p>
<p><strong>Rules 2.11 (Weak head reduction and normalization)</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_2$}
\AxiomC{$\Gamma \vdash c_2 \Downarrow c_3$}
\BinaryInfC{$\Gamma \vdash c_1 \Downarrow c_3$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \not\rightsquigarrow$}
\UnaryInfC{$\Gamma \vdash c \Downarrow c$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow S(c)$}
\UnaryInfC{$\Gamma \vdash p \rightsquigarrow c$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c_1 \rightsquigarrow c_1'$}
\UnaryInfC{$\Gamma \vdash c_1\ c_2 \rightsquigarrow c_1'\ c_2$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \rightsquigarrow c'$}
\UnaryInfC{$\Gamma \vdash \pi_1c \rightsquigarrow \pi_1c'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash c \rightsquigarrow c'$}
\UnaryInfC{$\Gamma \vdash \pi_2c \rightsquigarrow \pi_2c'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash (\lambda(\alpha:k).c_1)\ c_2 \rightsquigarrow
[c_2/\alpha]c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_1 \langle c_1, c_2 \rangle \rightsquigarrow c_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \pi_2 \langle c_1, c_2 \rangle \rightsquigarrow c_2$}
\end{prooftree}
\]</p>
<p>As before, we will restrict structural equality and natural kinding to only
apply to those tycons that are weak head normalized. Recall that such constructors
are either lambdas, \(\forall\)-types, or paths. We don't want to natural kind
lambdas or \(\forall\), since they will give us \(*\), which isn't what we're
looking for with these rules. As such, we have used \(p\) to represent path
constructors.</p>
<p><strong>Rules 2.12 (Natural Kind):</strong> \(\Gamma \vdash p \uparrow k\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \uparrow k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow \Pi(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash p\ c \uparrow [c/\alpha]k_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1p \uparrow k_1$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \uparrow \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2p \uparrow [\pi_1p/\alpha]k_2$}
\end{prooftree}
\]</p>
<p>Note that we don't bother looking up a natural kind for \(c_1\ c_2\), because it
will never be a singleton, so why bother?</p>
<p>Now, we can derive the earlier example. Letting \(\Gamma = \beta:*, \alpha:
S(\beta)\), we have</p>
<p>\[
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma(\alpha) = S(\beta)$}
\UnaryInfC{$\Gamma \vdash \alpha \uparrow S(\beta)$}
\UnaryInfC{$\Gamma \vdash \alpha \rightsquigarrow \beta$}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \beta \not\rightsquigarrow$}
\BinaryInfC{$\Gamma \vdash \alpha \Downarrow \beta$}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash \beta \not\rightsquigarrow$}
\UnaryInfC{$\Gamma \vdash \beta \Downarrow \beta$}
\AxiomC{}
\UnaryInfC{$\Gamma(\beta) = *$}
\UnaryInfC{$\Gamma \vdash \beta \leftrightarrow \beta:*$}
\TrinaryInfC{$\Gamma \vdash \alpha \Leftrightarrow \beta : *$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#structural-equivalence-at-last" id="structural-equivalence-at-last">Structural Equivalence, at last</a></h2>
<p>For completeness, the structural equality rules, which are largely unchanged
from \(F_\omega\):</p>
<p><strong>Rules 2.13 (Structural equality):</strong> \(\Gamma \vdash p \leftrightarrow p'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(\alpha) = k$}
\UnaryInfC{$\Gamma \vdash \alpha \leftrightarrow \alpha : k$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1 \Leftrightarrow \tau_1':*$}
\AxiomC{$\Gamma \vdash \tau_2 \Leftrightarrow \tau_2':*$}
\BinaryInfC{$\Gamma \vdash \tau_1 \rightarrow \tau_2 \leftrightarrow
\tau_1' \rightarrow \tau_2' : *$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k \Leftrightarrow k' : \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash c \Leftrightarrow c' : *$}
\BinaryInfC{$\Gamma \vdash \forall(\alpha:k).c \leftrightarrow
\forall(\alpha:k').c'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \leftrightarrow p' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_1p \leftrightarrow \pi_1p'$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash p \leftrightarrow p' : \Sigma(\alpha:k_1).k_2$}
\UnaryInfC{$\Gamma \vdash \pi_2p \leftrightarrow \pi_2p'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash p_1 \leftrightarrow p_2:\Pi(\alpha:k_1).k_2$}
\AxiomC{$\Gamma \vdash c_1 \Leftrightarrow c_2:k_1$}
\BinaryInfC{$\Gamma \vdash p_1\ c_1 \leftrightarrow p_1\ c_2:[c_1/\alpha]k_2$}
\end{prooftree}
\]</p>
<h2><a class="header" href="#remarks-2" id="remarks-2">Remarks</a></h2>
<ul>
<li>Professor Crary glossed over or entirely skipped some of the rules mentioned
here, particularly kind equivalence (which made the homework extra fun...).
I have included those rules from
Nick Roberts' notes for the sake of completeness.</li>
</ul>
<h1><a class="header" href="#binding" id="binding">Binding</a></h1>
<p>Up to now, when writing rules &quot;on the whiteboard&quot;, we have been blase about our
syntactic representation of variables and binding. In particular, all the rules
given only make sense if we implicitly assume that all rules apply up to alpha
equivalence, and that all substitutions are capture-avoiding. In doing so,
however, we necessarily gloss over any details of what an actual program
implementing these algorithms may need to ensure these invariants are upheld.</p>
<p>We now give some discussion on how these may be implemented in an actual
compiler. In the structural code for this class, we will use a hybrid of the
techniques discussed here -- terms will use explicit variables and constructors
will use De Bruijin indices. Past this explanation, we will continue to use the
notation for explicit variables everywhere, which should be implicitly converted
to De Bruijin where appropriate.</p>
<h2><a class="header" href="#explicit-variables" id="explicit-variables">Explicit Variables</a></h2>
<p>Consider (syntactically) the lambda calculus whose terms consist of variables,
lambda abstractions, and applications. Variables and bindings are &quot;explicit&quot;,
represented and differentiated with a literal string of characters (say \(x\)).
This has the example of being extremely simple to read, and has comparatively
few pitfalls to other approaches.</p>
<p>What would a substitution function on these terms look like? Certainly,
substituting into a variable or an application is easy. What about the lambda
case?</p>
<p>\[\require{bussproofs}
\begin{aligned}[]
[M/x]\lambda x.N &amp;= \lambda x.N \hfill&amp; \\
[M/x]\lambda y.N &amp;= \lambda y.[M/x]N \hfill&amp; (y \not\in FV(M)) \\
[M/x]\lambda y.N &amp;= \lambda y'.[M/x][y/y']N \hfill&amp; (y' \ne x, y \in FV(M),
y' \not\in FV(M))
\end{aligned}
\]</p>
<p>In the first case, we ignore the substitution -- the variable \(x\) is bound in
the lambda, so any suboccurrences of \(x\) aren't free (and thus shouldn't be
subbed). In the other two cases, we are forced to check whether \(y\) is free in
the substitutee \(M\), traversing the entire term each time. Then, if it is free
in \(M\), we <em>also</em> need to traverse the subterm \(N\) to alpha-vary it properly.</p>
<p>This is, as you may have surmised, not an ideal state of affairs. One
alternative is to just <em>always</em> alpha-vary the bound term, giving us the clause</p>
<p>\[
\begin{aligned}[]
[M/x]\lambda y.N &amp;= \lambda y'.[M/x][y/y']N \hfill&amp; (x \ne y, y' \ne x, y' \ne FV(M))
\end{aligned}
\]</p>
<p>where we generate a fresh variable each time. This is marginally better for
simplicity, but now requires us to traverse the subterm \(N\) every time.</p>
<h2><a class="header" href="#de-bruijin-indices" id="de-bruijin-indices">De Bruijin Indices</a></h2>
<p>Clearly, we need a better way. Another alternative we can use is <em>De Bruijin
indices</em>, in which a variable is represented by the number of binders between
the variable itself and its introduction. So the term \(\lambda x.x\ (\lambda y.
x\ y)\) would be written as \(\lambda . 0\ (\lambda. 1\ 0)\).</p>
<p>Related is the idea of De Bruijin <em>levels</em>, which count the indices backwards,
from the <em>outermost</em> binder. However, these are unwieldy and nobody uses them,
so we won't either.</p>
<p>Our substitution function, then, will look like this (remember that \(i\) and \(j\)
are <em>natural numbers</em> here):</p>
<p>\[
\begin{aligned}[]
[M/i]i &amp;= M \\
[M/i]j &amp;= j-1 \hfill&amp; (j &gt; i) \\
[M/i]j &amp;= j   \hfill&amp; (j \lt i) \\
[M/i](N_1\ N_2) &amp;= [M/i]N_1\ ([M/i]N_2) \\
[M/i]\lambda.N &amp;= \lambda.[M\uparrow^1_0/i+1]N
\end{aligned}
\]</p>
<p>where \(\uparrow\) is an operation that shifts the variables in a subterm (to be
defined). If \(j \lt i\), on the other hand, we can leave it be, as there isn't
an intermediate binding that has been removed.</p>
<p>In the \(j &gt; i\) case, we need to lower the variable by 1, because if we're
substituting for it, it means we've removed a binding site (namely, the binding
\(i\)).</p>
<p>When going underneath a binder (in the \(\lambda\)-abstraction case), we need to
adjust any variables in the substitutee \(M\) to account for the extra binder --
if \(M\) refers to some free variable at index \(0\), then that needs to become
index \(1\) once we go underneath the lambda binder. This is where the \(\uparrow\)
operation comes in:</p>
<p>\[
\begin{aligned}[]
i \uparrow^j_k &amp;= i + j \hfill&amp; (i \ge k) \\
i \uparrow^j_k &amp;= i \hfill&amp; (\text{otherwise}) \\
(M\ N) \uparrow^j_k &amp;= (M \uparrow^j_k)\ (N \uparrow^j_k) \\
(\lambda.M) \uparrow^j_k &amp;= \lambda.(M \uparrow^j_{k+1})
\end{aligned}
\]</p>
<p>Let's try this on some concrete examples. Consider the eta rule for \(\Pi\)-kinds:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, \alpha:k_1 \vdash c\ \alpha:k_2$}
\UnaryInfC{$\Gamma \vdash c : \Pi(\alpha:k_1).k_2$}
\end{prooftree}
\]</p>
<p>Under De Bruijin, this becomes</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, k_1 \vdash c\uparrow^1_0\ 0 : k_2$}
\UnaryInfC{$\Gamma \vdash c : \Pi(k_1).k_2$}
\end{prooftree}
\]</p>
<p>In the premise, we need to upshift any variables in the constructor \(c\), because
we're adding a new variable (namely, \(\alpha\)) without going underneath an
explicit binding site.</p>
<p>What about application?</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Pi(\alpha:k_1).k_2$}
\AxiomC{$\Gamma \vdash c':k_1$}
\BinaryInfC{$\Gamma \vdash c\ c' : [c'/\alpha]k_2$}
\end{prooftree}
\]</p>
<p>This becomes</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:\Pi(k_1).k_2$}
\AxiomC{$\Gamma \vdash c':k_1$}
\BinaryInfC{$\Gamma \vdash c\ c' : [c'/0]k_2$}
\end{prooftree}
\]</p>
<p>Here, because of how we defined substitution, we can avoid needing to do the
explicit downshift that comes from instantiating the \(\alpha\) binding.</p>
<h2><a class="header" href="#explicit-substitutions" id="explicit-substitutions">Explicit substitutions</a></h2>
<p>When working with such a representation, it can often be extremely unwieldy to
need to use the above definition for every substitution. Instead, we can use a
compositional representation acting on terms. Let \(\sigma\) be the syntactic
class of substitutions, which are, spiritually, functions from term to term,
applied as \(M[\sigma]\) (the reverse of the usual notation). Some presentations
of this system may even add \(M[\sigma]\) to the grammar as a term itself (called
a &quot;closure&quot;, confusingly), but we will not, for simplicit. We have</p>
<p>\[
\begin{aligned}
\sigma &amp;:= \uparrow^i \mid M.\sigma \\
\end{aligned}
\]</p>
<p>where \(M.\sigma\) is the substitution replacing variable \(0\) with \(M\) and
performing \(\sigma\) to \(i-1\) for each other variable \(i\). We will also define
the substitution \(id\) to be \(\uparrow^0\).</p>
<p>The substitution \([M_0/0, M_1/1, M_2/2]\), then, will be represented by the
operation \(M_0.M_1.M_2.id\).</p>
<p>With substitutions now represented as first-class, it makes sense to define the
composition of substitutions. Namely, we want \(\sigma \circ \sigma'\) to be
the transformation such that \(M[\sigma \circ \sigma'] = (M[\sigma])[\sigma']\).</p>
<p>Our application rules become:</p>
<p>\[\begin{aligned}
0[M.\sigma] &amp;= M \\
i+1[M.\sigma] &amp;= i[\sigma] \\
i [\uparrow^j] &amp;= i+j \\
(N\ P)[\sigma] &amp;= (N[\sigma]\ P[\sigma]) \\
(\lambda.M)[\sigma] &amp;= \lambda.(M[0.(\sigma \circ \uparrow^1)])
\end{aligned}
\]</p>
<p>with composition defined as</p>
<p>\[\begin{aligned}
(M.\sigma) \circ \sigma' &amp;= (M[\sigma']) . (\sigma \circ \sigma') \\
\uparrow^i \circ \uparrow^j &amp;= \uparrow^{i+j} \\
id \circ M.\sigma &amp;= M.\sigma \\
\uparrow^{i+1} \circ M.\sigma &amp;= \uparrow^i \circ \sigma
\end{aligned}
\]</p>
<p>Suppose, then, that we wanted to apply an operation \(\sigma\) to the second
variable in our binding list. To do that with what we have, we'd need to leave
all \(0\)s and \(1\)s untouched. We can do that with</p>
<p>\[
\sigma \rightsquigarrow 0.(\sigma \circ \uparrow) \rightsquigarrow
0.((0.(\sigma \circ \uparrow)) \circ \uparrow)
\]</p>
<p>where \(\rightsquigarrow\) is a transformation shifting a substitution to act
under one binding, and the last term is equal to</p>
<p>\[
0.(0[\uparrow].(\sigma \circ \uparrow) \circ \uparrow) =
0.1.(\sigma \circ \uparrow^2)
\]</p>
<p>This suggests a pattern:</p>
<p>\[
under_i(\sigma) = 0.1.\dots.i-1.\sigma \circ \uparrow^i
\]</p>
<p>which is to apply the operation \(\sigma\) under \(i\) bindings.</p>
<p>A typical use case may look like</p>
<p>\[
0.1.\dots.i-1.M_1[\uparrow^i].\dots.M_j[\uparrow^i].\uparrow^{i+k}
\]</p>
<p>In the starter code, this pattern is implemented for us as the function</p>
<pre><code class="language-ocaml">subst_term : nat -&gt; term list -&gt; nat -&gt; subst
</code></pre>
<h2><a class="header" href="#remarks-3" id="remarks-3">Remarks</a></h2>
<ul>
<li>I always find it simplest to think of the variable \(0\) as being an index into
the ordered context list. In this way, any time something is added to the
context <em>without</em> an explicit binder, it makes sense to increment the
internal vars.</li>
</ul>
<h1><a class="header" href="#continuation-passing-style" id="continuation-passing-style">Continuation Passing Style</a></h1>
<p>The next language we'll be covering is <code>IL-CPS</code>, whose purpose is to make
control flow explicit in the syntax of the language.</p>
<p>In particular, this language will have the following three properties:</p>
<ol>
<li>No implicit control flow -- procedure calls, returns, exceptions, etc. are
all represented as jumps.</li>
<li>All intermediate values are named.</li>
<li>Continuations are reified as 1st class values.</li>
</ol>
<p>To explain the second condition, instead of compound expressions like <code>x+y+z</code>,
in CPS form we would use something akin to <code>let x' = x+y in x'+z</code>.</p>
<p>There are some compilers whose CPS transformation pass only conforms to the
first two conditions. This is known as &quot;A-normal form&quot;, or &quot;monadic form&quot;. Or,
very creatively, &quot;2/3rds CPS&quot;.</p>
<h1><a class="header" href="#type-directed-translation" id="type-directed-translation">Type-directed Translation</a></h1>
<p>As usual, before we get into a full discussion of CPS, we'll need to develop
some more machinery.</p>
<p>Usually, language translations are &quot;syntax-directed&quot;, a translation judgment
defined inductively over the syntax tree. Between two types of lambda calculi,
for example, we might define our translation like this:</p>
<p>\[\require{bussproofs}
\begin{aligned}
\overline{x} &amp;= x \\
\overline{\lambda (x:\tau).e} &amp;= \lambda(x:\overline{\tau}).\overline{e} \\
\overline{e_1\ e_2} &amp;= \overline{e_1}\ \overline{e_2}
\end{aligned}
\]</p>
<p>where the the translation can be determined solely by looking at the particular
syntactic form.</p>
<p>One problem: This doesn't always work.</p>
<p>For example, consider translating a language with booleans into System
\(F_\omega\). Under a standard Church encoding, we'd translate the type <code>bool</code> as</p>
<p>\[
\overline{bool} = \forall(\alpha:*).(\alpha \rightarrow \alpha \rightarrow \alpha)
\]</p>
<p>with the corresponding introduction forms</p>
<p>\[
\begin{aligned}
\overline{true} &amp;= \Lambda \alpha.\lambda(x:\alpha).\lambda(y:\alpha).x \\
\overline{false} &amp;= \Lambda \alpha.\lambda(x:\alpha).\lambda(y:\alpha).y \\
\end{aligned}
\]</p>
<p>A problem, however, comes when trying to translate the elimination form:</p>
<p>\[
\overline{if\ e_1\ then\ e_2\ else\ e_3} = \overline{e_1}[\tau]\ \overline{e_2}
\ \overline{e_3}
\]</p>
<p>What type should we use for \(\tau\)? It should be the type of \(e_1\) and \(e_2\),
but without actually running a typechecker, we won't know what type that is! To
deal with this, we can use a <em>type-directed</em> translation, which couples the
translation step with the typechecking/type synthesis process.</p>
<p>Of course, there are really <em>two</em> typing judgments here, one for the source and
one for the target language. These are usually notated</p>
<p>\[
\begin{aligned}
\Gamma \vdash_S e:\tau \\
\Gamma \vdash_T e:\tau
\end{aligned}
\]</p>
<p>for <strong>s</strong>ource and <strong>t</strong>arget, respectively. However, we will elide the
subscripts in cases where the context makes it clear, typically when we know
what language the given term is in.</p>
<p>Our translation judgment, then, becomes</p>
<p>\[\Gamma \vdash_S e:\tau \rightsquigarrow e'\]</p>
<p>where \(e\) is in the source and \(e'\) is in the target language.</p>
<p>Note that we can actually use a syntax-directed translation of constructors,
kinds and contexts. For a more complex constructor language, we may need to
perform a <em>kind</em>-directed translation, but we will avoid that for reasons to
be discussed.</p>
<p>A translation, then, should have the following regularity conditions:</p>
<ol>
<li>\(\Gamma \vdash_S \tau: *\) if and only if \(\overline{\Gamma} \vdash_T
\overline{\tau}: *\).</li>
<li>\(\Gamma \vdash_S e:\tau\) if and only if there exists some \(e'\) such that
\(\Gamma \vdash_S e:\tau \rightsquigarrow e'\).</li>
<li>If \(\Gamma \vdash_S e:\tau \rightsquigarrow e'\), then \(\overline{\Gamma}
\vdash_T e':\overline{\tau}\) (static correctness).</li>
</ol>
<p>You might think that, since we have a notion of static correctness, we may also
have some form of <em>dynamic</em> correctness to preserve. Loosely, this might be
phrased as &quot;If \(\Gamma \vdash e:\tau \rightsquigarrow e'\), then \(e\) and \(e'\)
'do the same thing'&quot;. However, it is actually quite difficult to even state
this formally! Certainly, we can't state this without having some formal notion
of dynamic behavior, which we won't be dealing with in this class. It turns out
that these proofs are also quite involved, which is another reason we don't
bother.</p>
<p>A type-directed translation rule will always follow the same form of the
associated regular typing rule, where the premises are also a translation. The
variable translation rule, for example might look like this:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau \rightsquigarrow x$}
\end{prooftree}
\]</p>
<p>In general, it is best not to touch variable names. If we do start messing with
variable names, we'll need to ensure freshness, perform substitutions on
subterms, and so on -- not worth it at all.</p>
<p>Returning to the if-then-else example, we can now express the correct
translation (assuming the usual rule for typing if-then-else):</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:bool \rightsquigarrow e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau \rightsquigarrow e_2'$}
\AxiomC{$\Gamma \vdash e_3:\tau \rightsquigarrow e_3'$}
\TrinaryInfC{$\Gamma \vdash if\ e_1\ then\ e_2\ else\ e_3:\tau
\rightsquigarrow e_1'[\overline{\tau}]\ e_2'\ e_3'$}
\end{prooftree}
\]</p>
<p>Finally, note that these rules will need to be adjusted somewhat to work with
the algorithmic type synthesis and type checking rules.</p>
<p>Although we have not given a full formal system, we can sketch out what a proof
of the regularity conditions may look like:</p>
<ol>
<li>Depends on the specifics of the kind system, but often follows via
induction on the kinding judgment (in both directions).</li>
<li>The forward direction is fairly clear, as we design our rules to follow
from the source typing judgment. The backwards direction is even easier,
as we can simply delete the translations from every premise and conclusion
to show what we need.</li>
<li>Was not given in lecture; can be proven relatively easily for yourself.</li>
</ol>
<h2><a class="header" href="#coherence" id="coherence">Coherence</a></h2>
<p>An important property of translations in general is <em>coherence</em>, namely that
translations are unique.</p>
<p>Suppose that \(\Gamma \vdash_S e:\tau\), and so \(\Gamma \vdash e:\tau
\rightsquigarrow e'\). What if we also have \(\Gamma \vdash e:\tau \rightsquigarrow
e''\)? In our cases, this will generally be impossible, as our translations are
based on typing judgments and typing judgments are unique. In real languages, on
the other hand, this is not necessarily the case. The statement of coherence,
then, in this case, is that \(e' = e''\). It is <em>very</em> difficult to prove this, so
we won't.</p>
<p>For example, what if we're in a language with subtyping? The typical subsumption
rule,</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\tau$}
\AxiomC{$\Gamma \vdash \tau' \le \tau$}
\BinaryInfC{$\Gamma \vdash e:\tau'$}
\end{prooftree}
\]</p>
<p>actually translates to <em>coercion</em> code in a type-directed setting:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\tau \rightsquigarrow e'$}
\AxiomC{$\Gamma \vdash \tau' \le \tau \rightsquigarrow f$}
\BinaryInfC{$\Gamma \vdash e:\tau' \rightsquigarrow f\ e'$}
\end{prooftree}
\]</p>
<p>where \(f\) is the function witnessing that \(\tau'\) subsumes \(\tau\). Of course,
as SML lacks subtyping, we aren't going to bother.</p>
<p>This does, however, bring us back to why we don't perform a kind-directed
translation for type constructors -- we <em>do</em> have subkinding! So designing a
coherent system for that becomes much more difficult.</p>
<h2><a class="header" href="#remarks-4" id="remarks-4">Remarks</a></h2>
<ul>
<li>In lecture, Prof. Crary chose to use \(\overline{e}\) as the &quot;output&quot; of the
translation judgment, where \(\overline{\cdot}\) here is not acting as an
operator, just taking the symbol \(\overline{e}\) as a suggestive variable
name. I have taken the liberty of rephrasing the rules to use something
else for the sake of my own confusion.</li>
<li>I did a few cases of the proof of the translation from IL-Direct to IL-CPS
and it seems to be fairly straightforward. The third condition can be shown
by induction over the translation rules, but is muddied by the presence of
different syntactic classes.</li>
<li>Later, there was some discussion about Kleene equivalence, but I zoned out
and didn't catch a lot of it (it wasn't particularly relevant to this
material). It is a weaker property than full dynamic equivalence; it holds
when \(e_1\) halts iff \(e_2\) halts.</li>
</ul>
<h1><a class="header" href="#introduction-to-continuation-passing-style" id="introduction-to-continuation-passing-style">Introduction to Continuation Passing Style</a></h1>
<p>Before we can discuss the translation, we must specify our source and target
languages.</p>
<h2><a class="header" href="#source-il-direct" id="source-il-direct">Source: IL-Direct</a></h2>
<table><thead><tr><th>Sort</th><th></th><th></th></tr></thead><tbody>
<tr><td>Kinds</td><td>\(k:=\)</td><td>\(* \mid S(c) \mid \Pi(\alpha:k).k \mid \Sigma(\alpha:k).k\)</td></tr>
<tr><td>Tycons</td><td>\(c:=\)</td><td>\(\alpha \mid \lambda(\alpha:k).c \mid c\ c \mid \langle c, c\rangle \mid \pi_1c \mid \pi_2c\)</td></tr>
<tr><td>(Types)</td><td>\((\tau)\)</td><td>\(\phantom{\alpha} \mid \forall(\alpha:k).\tau \mid \tau \rightarrow \tau \mid \tau \times \tau\)</td></tr>
<tr><td>Terms</td><td>\(e:=\)</td><td>\(x \mid \Lambda(\alpha:k).e \mid e[c] \mid \lambda(x:\tau).e \mid e\ e\)</td></tr>
<tr><td></td><td></td><td>\(\phantom{x} \mid \langle e, e \rangle \mid \pi_1e \mid \pi_2e\)</td></tr>
</tbody></table>
<p>For the most part, the kinds and the non-\(\tau\) type constructors will be the
same for the rest of the class. The <em>types</em>, on the other hand, will be changing
quite frequently, as will the terms (obviously). In a real implementation, we'll
also be adding some <em>actual</em> base types, like <code>int</code>, <code>bool</code>, <code>exn</code>, <code>ref</code>, etc.</p>
<h2><a class="header" href="#target-il-cps" id="target-il-cps">Target: IL-CPS</a></h2>
<table><thead><tr><th>Sort</th><th></th><th></th></tr></thead><tbody>
<tr><td>Kinds</td><td>\(k:=\)</td><td>same</td></tr>
<tr><td>Tycons</td><td>\(c:=\)</td><td>same</td></tr>
<tr><td>(Types)</td><td>\((\tau)\)</td><td>\(\dots \mid \exists(\alpha:k).\tau \mid \neg\tau \mid \tau \times \tau\)</td></tr>
<tr><td>Values</td><td>\(v:=\)</td><td>\(x \mid \lambda(x:\tau).e \mid \langle v, v \rangle \mid pack\ [c,v]\ as\ \exists(\alpha:k).\tau\)</td></tr>
<tr><td>Expressions</td><td>\(e:=\)</td><td>\(let\ x=v\ in\ e \mid v\ v \mid let\ x = \pi_1v\ in\ e \mid let\ x = \pi_2v\ in\ e\)</td></tr>
<tr><td></td><td></td><td>\(\phantom{x} \mid unpack\ [\alpha,x] = v\ in\ e \mid halt\)</td></tr>
</tbody></table>
<p>Properly, we might notate \(\neg\tau\) as \(\tau \rightarrow answer\) or \(\tau
\rightarrow 0\), to notate that lambdas (really, continuations) don't return.
However, by marking it as \(\neg\tau\), some of the type relationships become more
obvious. Similarly, the \(v\ v\) syntactic form is more of a jump than a function
call.</p>
<p>If we had booleans (particularly if-then-else), we might add \(if\ v\ then\ e\ else\ e\)
for this. Instead of nesting expressions, we need to <em>bind</em> them into values
before they can be used. For this reason, this is a &quot;monadic form&quot;.</p>
<h2><a class="header" href="#basic-principles" id="basic-principles">Basic Principles</a></h2>
<p>When translating kinds and contexts, we can largely do the obvious thing. With
types, on the other hand, we have some work to do. We have</p>
<p>\[\require{bussproofs}\overline{\tau_1 \rightarrow \tau_2} = \neg(\overline{\tau_1} \times \neg
\overline{\tau_2})\]</p>
<p>Intuitively, we can think of a function, in CPS, as a jump taking the standard
parameter (\(\overline{\tau_1}\)) and also a continuation argument telling where
to jump with the result (\(\neg\overline{\tau_2}\)). In the theory, the slick way
to see it is that \(A \implies B\) is equivalent to \(\neg A \lor B\), which is
in turn equivalent to \(\neg (A \land \neg B)\) by De Morgan's law. It turns out
that programming in the presence of continuations actually encodes <em>classical</em>
logic under Curry-Howard, where the proof of a proposition \(\tau\) can be
contradicted with (thrown to) a <em>continuation</em> \(\neg \tau\), which diverges
(produces \(\bot\)). Classical and constructive logic coincide on \(\Pi_2\)
sentences, which are sentences of the form \(\forall \dots \forall . \exists
\dots \exists . p\) (either of the quantifier prefix lists can be empty), where
\(p\) is a decidable proposition.</p>
<p>By Curry-Howard, the translation \(M:A \rightsquigarrow \overline{M}:
\overline{A}\) transforms the proof \(M\) to remove uses of double negation
elimination (known in PL parlance as <code>callcc</code>). If \(A\) is \(\Pi_2\), we can
extract a proof of \(A\) from a proof of \(\overline{A}\) in this way.</p>
<p>You may also notice that IL-CPS does not have \(\forall\) types, only \(\exists\).
We use the translation</p>
<p>\[\overline{\forall(\alpha:k).\tau} = \neg(\exists(\alpha:\overline{k}).\neg
\overline{\tau})\]</p>
<p>again using the classical tautology \(\forall x.p \Leftrightarrow \neg \exists
x. (\neg p)\). Computationally, this transforms a <em>function</em> taking the
constructor \(\alpha\) and returning a value into a continuation that takes an
<em>existential</em> holding \(\alpha\) and an internal continuation taking the resulting
\(\tau\) value. We don't actually want to have \(\forall(\alpha:k).\tau\) as a
type in our CPS language. It is workable, but very strange -- some function
calls become <em>values</em>, and so on. Doing this actually produces better code at
the expense of some unfortunate semantics (for example, the value restriction
resurfaces).</p>
<p>Some regularity conditions:</p>
<ol>
<li>If \(\Gamma \vdash k:\text{kind}\), then \(\overline{\Gamma} \vdash \overline{k}
:\text{kind}\)</li>
<li>If \(\Gamma \vdash c:k\), then \(\overline{\Gamma} \vdash \overline{c}:\overline{k}\)</li>
</ol>
<p>A third property that's nice to have is that the translation commutes with
substitution:</p>
<p>\[\overline{[c_1/\alpha]c_2} = [\overline{c_1}/\alpha]\overline{c_2}\]</p>
<p>which holds if we don't mess with the variables.</p>
<p>The translation judgment itself will need to be a little weird to accommodate
the CPS property. Instead of using the typical \(\Gamma \vdash e:\tau \rightsquigarrow
e'\), we're going to bind an explicit continuation argument \(\Gamma \vdash
e:\tau \rightsquigarrow x.e'\), where \(x\) is a bound continuation of type \(\neg
\overline\tau\). We can think of this translation as assuming a continuation
to pass the &quot;result&quot; of evaluating the expression \(e\) to.</p>
<p>Properly, of course, continuation arguments are named \(k\) by convention. We
already use \(k\) for kinds, but the two appear in different contexts, so there's
no possibility of confusion.</p>
<h2><a class="header" href="#statics-of-il-cps" id="statics-of-il-cps">Statics of IL-CPS</a></h2>
<p>Because of the value-expression modality, we need to adjust our definition of
static correctness:</p>
<ul>
<li>If \(\Gamma \vdash e:\tau \rightsquigarrow k.e'\) and \(\vdash \Gamma\ ok\), then
\(\overline{\Gamma}, k:\neg \overline{\tau} \vdash e':0\)</li>
</ul>
<p>The \(0\) in this expression typing judgment denotes that, in this language,
expressions diverge -- they have type <code>void</code>, effectively. Values, of course,
are typed as usual.</p>
<p>IL-CPS, then, is defined statically as follows:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau:*$}
\AxiomC{$\Gamma, x:\tau \vdash e:0$}
\BinaryInfC{$\Gamma \vdash \lambda(x:\tau).e : \neg \tau$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash v_1:\tau_1$}
\AxiomC{$\Gamma \vdash v_2:\tau_2$}
\BinaryInfC{$\Gamma \vdash \langle v_1, v_2 \rangle : \tau_1 \times \tau_2$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash c:k$}
\AxiomC{$\Gamma \vdash v:[c/\alpha]\tau$}
\AxiomC{$\Gamma, \alpha:k \vdash \tau:*$}
\TrinaryInfC{$\Gamma \vdash pack\ [c,v]\ in\ \exists(\alpha:k).\tau$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash v_1:\neg \tau$}
\AxiomC{$\Gamma \vdash v_2:\tau$}
\BinaryInfC{$\Gamma \vdash v_1\ v_2:0$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash v:\tau$}
\AxiomC{$\Gamma, x:\tau \vdash e:0$}
\BinaryInfC{$\Gamma \vdash let\ x=v\ in\ e:0$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash x:\tau_1 \times \tau_2$}
\AxiomC{$\Gamma, x:\tau_1 \vdash e:0$}
\BinaryInfC{$\Gamma \vdash let\ x=\pi_1v\ in\ e:0$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash x:\tau_1 \times \tau_2$}
\AxiomC{$\Gamma, x:\tau_2 \vdash e:0$}
\BinaryInfC{$\Gamma \vdash let\ x=\pi_2v\ in\ e:0$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash v:\exists(\alpha:k).\tau$}
\AxiomC{$\Gamma,\alpha:k,x:\tau \vdash e:0$}
\BinaryInfC{$\Gamma \vdash unpack\ [\alpha,x]=v\ in\ e:0$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash halt:0$}
\end{prooftree}
\]</p>
<h1><a class="header" href="#basic-translation" id="basic-translation">Basic Translation</a></h1>
<p>Our initial discussion of CPS transformation centers around &quot;direct-style&quot; code,
which features no abnormal control flow operators (exceptions, continuations,
etc).</p>
<p>We discussed this a bit briefly in the last section, but here are the collected
type translation rules for IL-CPS:</p>
<p>\[\require{bussproofs}
\begin{aligned}
\overline{\alpha} &amp;= \alpha \\
\overline{\tau_1 \times \tau_2} &amp;= \neg(\overline{\tau_1} \times \overline{\tau_2}) \\
\overline{\tau_1 \rightarrow \tau_2} &amp;= \neg(\overline{\tau_1} \times \neg
\overline{\tau_2}) \\
\overline{\forall(\alpha:k).\tau} &amp;= \neg(\exists(\alpha:\overline{k}).
\neg\overline{\tau})
\end{aligned}
\]</p>
<p><strong>Rules 3.1 (CPS-conversion):</strong> \(\Gamma \vdash e:\tau \rightsquigarrow k.e'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau \rightsquigarrow k.k\ x$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau_1 \rightsquigarrow k_1.e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau_2 \rightsquigarrow k_2.e_2'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash \langle e_1, e_2 \rangle :\tau_1 \times \tau_2 \rightsquigarrow k.&amp;
let\ k_1= \lambda(x_1:\overline{\tau_1}).\\
&amp;\quad (let\ k_2=\lambda(x_2:\overline{\tau_2}).k \langle x_1, x_2 \rangle
\ in\ e_2') \\
&amp;in\ e_1'
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e : \tau_1 \times \tau_2 \rightsquigarrow k.e'$}
\UnaryInfC{$
\begin{aligned}
\Gamma \vdash \pi_ie : \tau_i \rightsquigarrow k'.&amp;
let\ k=\lambda(x:\overline{\tau_1} \times \overline{\tau_2}). \\
&amp;\quad (let\ y = \pi_ix\ in\ k'\ y) \\
&amp;in\ e'
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau:*$}
\AxiomC{$\Gamma, x:\tau \vdash e:\tau' \rightsquigarrow k.e'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash \lambda(x:\tau).e: \tau \rightarrow \tau' \rightsquigarrow k'.
&amp;k' (\lambda(y:\overline{\tau} \times \neg\overline{\tau'}). \\
&amp;\qquad let\ x=\pi_1y\ in \\
&amp;\qquad let\ k=\pi_2y\ in\ e')
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau_1 \rightarrow \tau_2 \rightsquigarrow
k_1.e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau_1 \rightsquigarrow k_2.e_2'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash e_1\ e_2:\tau' \rightsquigarrow k.&amp;let\ k_1 =
\lambda(x_1:\neg(\overline{\tau_1}\times \neg\overline{\tau_2})). \\
&amp;\quad (let\ k_2 = \lambda(x_2:\tau_1).x_1\langle x_2,k \rangle\ in\ e_2') \\
&amp;in\ e_1'
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash k: \text{kind}$}
\AxiomC{$\Gamma, \alpha:k \vdash \tau:*$}
\AxiomC{$\Gamma, \alpha:k \vdash e:\tau \rightsquigarrow k.e'$}
\TrinaryInfC{$
\begin{aligned}
\Gamma \vdash \Lambda(\alpha:k).e : \forall(\alpha:k).\tau \rightsquigarrow k'.
&amp;k'( \lambda(y:\exists(\alpha:\overline{k}).\neg \overline{\tau}).\\
&amp;\quad unpack [\alpha,k] = y\ in\ e')
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\forall(\alpha:k).\tau \rightsquigarrow k.e'$}
\AxiomC{$\Gamma \vdash c:k$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash e[c]:[c/\alpha]\tau \rightsquigarrow k'.&amp;
let\ k=\lambda(f:\neg(\exists(\alpha:\overline{k}).\neg\overline{\tau})). \\
&amp;\quad f(pack\ [\overline{c},k']\ as\ \exists(\alpha:\overline{k}).
\neg \overline{\tau}) \\
&amp;in\ e'
\end{aligned}
$}
\end{prooftree}
\]</p>
<p>The important thing to keep in mind while devising these rules is that, when we
recursively translate a
sub-expression \(e\), we are given some bound term \(k.e'\), in which the bound \(k\)
is a continuation taking the &quot;result&quot; of \(e'\) as input. When we <em>use</em> this
result, then, \(k\) is <em>free</em>! To complete the translation, then, we have to
re-bind \(k\) to be a continuation of the correct type
(particularly, \(k\) has type \(\neg \overline\tau\) if \(e\) has type \(\tau\)).</p>
<h2><a class="header" href="#remarks-5" id="remarks-5">Remarks</a></h2>
<ul>
<li>I personally found it easier to chase types rather than try to reason through
the control flow. The two main patterns I used for intuition are that
\(let\ k=\dots\ in\ e\) is the translation of &quot;evaluate \(e \rightsquigarrow
k.e\)&quot; and \(k\ v\) is the translation of &quot;\(v\) is a value&quot;.</li>
</ul>
<h1><a class="header" href="#other-evaluation-strategies" id="other-evaluation-strategies">Other evaluation strategies</a></h1>
<p>In this section, we discuss CPS conversion for a few other evaluation schemes.</p>
<h2><a class="header" href="#call-by-name" id="call-by-name">Call by Name</a></h2>
<p>The primary counterpart to so-called &quot;strict&quot; evaluation is &quot;lazy&quot; evaluation,
otherwise known as &quot;call by name&quot; (as opposed to &quot;call by value&quot;) semantics.
The key difference, of course, is that sub-expressions aren't evaluated until
they are eliminated, leading to things like function arguments being passed as
thunks, and so on.</p>
<p>As the key idea behind CPS is to make ccontrol flow very explicit, it stands to
reason that it doesn't matter whether IL-CPS is by name or by value, something
that the expression-value divide enforces. The difference, then, is expressed
in the <em>translation</em> from a call-by-name language to continuation passing style.</p>
<p>Conceptually, this works out with bound variables in contexts having a moral
type of \(\neg \neg \tau\) (taking in the &quot;what do I do next&quot; continuation),
rather than \(\tau\). The primary place this manifests is in the translation of
contexts:</p>
<p>\[\require{bussproofs}\overline{\Gamma, x:\tau} = \overline{\Gamma}, x:\neg\neg\overline\tau\]</p>
<p>We also need to adjust our translation of function types to account for this:</p>
<p>\[\overline{\tau_1 \rightarrow \tau_2} =
\neg(\neg \neg \overline{\tau_1} \times \neg \overline{\tau_2})
\]</p>
<p>Now, as it turns out, we can get away with only changing a few rules from their
previous definitions:</p>
<p><strong>Rules 3.2 (Call by name translation)</strong></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau \rightsquigarrow x\ k$}
\end{prooftree}
\]</p>
<p>Remember that here, the translated \(x\) has type \(\neg\neg \tau\), so instead of
passing the final value \(x\) to \(k\), we pass the continuation \(k\) to \(x\).</p>
<p><em>Rules 3.2 cont'd</em></p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau_1:*$}
\AxiomC{$\Gamma, x:\tau \vdash e:\tau_2 \rightarrow k.e'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash \lambda(x:\tau).e:\tau_1 \rightarrow \tau_2 \rightsquigarrow k'.
k'(&amp;\lambda(y:\neg\neg\overline{\tau_1} \times \neg\overline{\tau_2}).\\
&amp;\quad let\ x=\pi_1y\ in \\
&amp;\quad let\ k=\pi_2y\ in\ e')
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau_1 \rightarrow \tau_2 \rightsquigarrow k_1.e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau_1 \rightsquigarrow k_2.e_2'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash e_1\ e_2:\tau_2 \rightsquigarrow k.&amp;
let\ k_1 = \lambda(f:\neg(\neg \neg \overline{\tau_1}\times \neg\overline{\tau_2})).
\\
&amp;\quad f \langle (\lambda(k_2:\neg\overline{\tau_1}).e_2'), k\rangle \\
&amp;in\ e_1'
\end{aligned}
$}
\end{prooftree}
\]</p>
<p>The function rule is actually almost completely the same, but is reproduced to
demonstrate the type change. In the application rule, instead of evaluating the
argument \(e_2'\), we reify it as a thunk to pass as the first argument to the
resultant jump.</p>
<p>In fact, these are all the changes we need to change the previous translation
into a call by name version! There are often other lazy constructs (such as lazy
tuples), but we won't discuss them here.</p>
<h3><a class="header" href="#aside-call-by-need" id="aside-call-by-need">Aside: Call by &quot;need&quot;</a></h3>
<p>One issue with naive call by name is that, if a given input is used multiple
times, it may need to be evaluated multiple times. These <em>can</em> be optimized out
in some cases, but in the presence of effects this doesn't help in the general
case. Instead, we can use some memoization to cache the results of computations
after they've been used once. This is the evaluation strategy used by Haskell,
which has the name &quot;call by need&quot;.</p>
<p>Under the hood, this is used by storing a datatype <code>UNFORCED of unit -&gt; 'a | FORCED of 'a</code> for the lazy thunks, and then internally using a ref to track
them, replacing <code>UNFORCED</code> with <code>FORCED</code> when necessary. This, ironically, leads
to Haskell being less naively parallelizable than ML, as there are now mutable
data dependencies to worry about (in an ostensibly completely pure language).
To get around this, GHC actually does some strictness analysis, compiling what
code it can to a call-by-value language, then leaving the rest as call by need.</p>
<h2><a class="header" href="#callcc" id="callcc">Call/cc</a></h2>
<p>Scheme popularized the idea of reified first-class continuations with the
<code>callcc</code> construct. For use of this concept, SMLNJ exposes two functions:</p>
<pre><code class="language-ocaml">callcc: ('a cont -&gt; 'a) -&gt; 'a
throw: 'a cont * 'a -&gt; 'b
</code></pre>
<p>Instead of using functions, however, we're going to make these primitive
constructs in our source language, defined statically as:</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, x:\tau\ cont \vdash e:\tau$}
\AxiomC{$\Gamma \vdash \tau:*$}
\BinaryInfC{$\Gamma \vdash letcc\ x\ in\ e:\tau$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau$}
\AxiomC{$\Gamma \vdash e_2:\tau\ cont$}
\AxiomC{$\Gamma \vdash \tau':*$}
\TrinaryInfC{$\Gamma \vdash throw\ e_1\ to\ e_2:\tau'$}
\end{prooftree}
\]</p>
<p>Suggestively, the target language is <em>continuation passing style</em> for a reason,
which suggests the translation of \(\tau\ cont\) to \(\neg \tau\). We can translate
these two new constructs as</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma, x:\tau\ cont \vdash e:\tau \rightsquigarrow k.e'$}
\AxiomC{$\Gamma \vdash \tau:*$}
\BinaryInfC{$\Gamma \vdash letcc\ x\ in\ e:\tau \rightsquigarrow k.
let\ x=k\ in\ e'$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau \rightsquigarrow k_1.e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau\ cont \rightsquigarrow k_2.e_2'$}
\AxiomC{$\Gamma \vdash \tau':*$}
\TrinaryInfC{$
\begin{aligned}
\Gamma \vdash throw\ e_1\ to\ e_2:\tau' \rightsquigarrow k.&amp;
let\ k_1=\lambda(x:\overline{\tau}).\\
&amp;\quad let\ k_2=\lambda(f:\neg\overline{\tau}).f\ x\ in\ e_2'\\
&amp;in\ e_1'
\end{aligned}
$}
\end{prooftree}
\]</p>
<p>Unsurprisingly, \(letcc\) involves capturing the current continuation, which is
<em>conveniently</em> passed as the bound \(k\). For \(throw\), we evaluate both \(e_1\) and
\(e_2\), and then pass the result of \(e_2\) to the continuation hidden in \(e_2\).</p>
<h2><a class="header" href="#remarks-6" id="remarks-6">Remarks</a></h2>
<ul>
<li>I'm not entirely sure what the issue is with refs in parallel for Haskell.
Even if multiple threads try to write to the ref cell at once (assuming
atomic reads and writes, of course), there would be no correctness issues,
as both threads would be writing the same value anyway (in a pure language).
Prof. Crary said that this kind of strategy causes issues with garbage
collection but didn't go into detail.</li>
</ul>
<h1><a class="header" href="#exception-passing" id="exception-passing">Exception passing</a></h1>
<p>A more involved form of advanced control flow is that of exceptions that
automatically propagate up the call stack until being handled.</p>
<h2><a class="header" href="#aside-typed-exceptions" id="aside-typed-exceptions">Aside: Typed exceptions</a></h2>
<p>In ML, the type <code>exn</code> is special in that new variants can be added to it at
runtime. This is the so-called <em>extensible</em> type, a dynamically-growing sum
type.</p>
<p>This extensibility is actually entirely separate from the concept of exceptions
as a control flow tool, despite the two being often conflated. To sidestep
dealing with this issue, we will assume the existence of a type \(\tau_{ex}\),
the type of <em>exception objects</em>. This type could be <code>int</code>, <code>void</code>, <code>exn</code>, or so
on, it doesn't matter.</p>
<h2><a class="header" href="#syntax-of-exceptions" id="syntax-of-exceptions">Syntax of exceptions</a></h2>
<p>Statically, we will define exception handling as follows:</p>
<p>\[\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau$}
\AxiomC{$\Gamma, x:\tau_{ex} \vdash e_2:\tau$}
\BinaryInfC{$\Gamma \vdash try\ e_1\ with\ x.e_2:\tau$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\tau_{ex}$}
\AxiomC{$\Gamma \vdash \tau : *$}
\BinaryInfC{$\Gamma \vdash raise\ e:\tau$}
\end{prooftree}
\]</p>
<p>Because every expression may now have a separate evaluation condition (namely,
&quot;raising an exception&quot;), we also need to change some our translation strategy.
Previously, we only bound the one continuation <code>k</code> for the singular exit
condition. Now, we'll also have a continuation <code>k_ex</code>, which is called with the
raised exception of a given expression. For the obvious reason, this style of
evaluation is often described as &quot;double-barrelled CPS&quot;.</p>
<p>We also need to adjust our type translation:</p>
<p>\[\overline{\tau_1 \rightarrow \tau_2} \rightsquigarrow \neg(\overline{\tau_1}
\times \neg \overline{\tau_2} \times \neg \overline{\tau_{ex}})\]</p>
<p>The translation judgment, then, becomes</p>
<p>\[\Gamma \vdash e:\tau \rightsquigarrow k.k_{ex}.e'\]</p>
<p>with coherence condition</p>
<ul>
<li>If \(\Gamma \vdash e:\tau \rightsquigarrow k.k_{ex}.e'\), and \(\vdash \Gamma
\ ok\), then \(\overline{\Gamma}, k:\neg \overline{\tau}, k_{ex}:\neg
\overline{\tau_{ex}} \vdash e':0\)</li>
</ul>
<p>In most cases, we will simply thread the same \(k_{ex}\) through the same
translations developed in the previous section. For example, we might have</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau_1 \rightsquigarrow k_1.k_{ex}.e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau_2 \rightsquigarrow k_2.k_{ex}.e_2'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash \langle e_1, e_2 \rangle :\tau_1 \times \tau_2 \rightsquigarrow
k.k_{ex}.&amp;
let\ k_1= \lambda(x_1:\overline{\tau_1}).\\
&amp;\quad (let\ k_2=\lambda(x_2:\overline{\tau_2}).k \langle x_1, x_2 \rangle
\ in\ e_2') \\
&amp;in\ e_1'
\end{aligned}
$}
\end{prooftree}
\]</p>
<p>where we use the same exception handler for the premises as the conclusion.</p>
<p><strong>Rules 3.3 (Double-barrelled CPS, selected rules only)</strong>: \(\Gamma \vdash e:\tau
\rightsquigarrow k.k_{ex}.e'\)</p>
<p>\[
\begin{prooftree}
\AxiomC{$\Gamma(x) = \tau$}
\UnaryInfC{$\Gamma \vdash x:\tau \rightsquigarrow k.k_{ex}.k\ x$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau:*$}
\AxiomC{$\Gamma, x:\tau \vdash e:\tau' \rightsquigarrow k'.k_{ex}'.e'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash \lambda(x:\tau).e: \tau \rightarrow \tau' \rightsquigarrow
k.k_{ex}.
&amp;k (\lambda (y:\overline{\tau} \times \neg\overline{\tau'} \times
\neg\overline{\tau_{ex}}). \\
&amp;\qquad let\ x=\pi_1y\ in \\
&amp;\qquad let\ z=\pi_2y\ in \\
&amp;\qquad let\ k'=\pi_1z\ in \\
&amp;\qquad let\ k_{ex}'=\pi_2z\ in\ e')
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau \rightarrow \tau' \rightsquigarrow k_1.k_{ex}.e_1'$}
\AxiomC{$\Gamma \vdash e_2:\tau \rightarrow \tau' \rightsquigarrow k_2.k_{ex}.e_2'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash e_1\ e_2 : \tau' \rightsquigarrow k.k_{ex}.
&amp;let\ k_1' = \lambda(f:\neg(\overline{\tau} \times \neg\overline{\tau'} \times
\neg\overline{\tau_{ex}})). \\
&amp;\qquad (let\ k_2 = \lambda(x:\overline{\tau}).f \langle x,
\langle k, k_{ex} \rangle \rangle\ in\ e_2') \\
&amp;in\ e_1'
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e:\tau \rightsquigarrow k.k_{ex}.e'$}
\AxiomC{$\Gamma, x:\tau_{ex} \vdash e_{ex} : \tau \rightsquigarrow
k.k_{ex}'.e_{ex}'$}
\BinaryInfC{$
\begin{aligned}
\Gamma \vdash try\ e\ with\ x.e_{ex}:\tau \rightsquigarrow k.k_{ex}'.
let\ k_{ex}=\lambda(x:\overline{\tau_{ex}}).e_{ex}'\ in\ e'
\end{aligned}
$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau:*$}
\AxiomC{$\Gamma \vdash e:\tau_{ex} \rightsquigarrow k.k_{ex}.e'$}
\BinaryInfC{$\Gamma \vdash raise_\tau\ e:\tau \rightsquigarrow k'.k_{ex}.[k_{ex}/k]e'$}
\end{prooftree}
\]</p>
<p>Note that we are treating products as right-associative for the purpose of the
\(\pi_1\) and \(\pi_2\) expressions. In the <code>raise</code> case, we can simply evaluate the
exception expression \(e\), passing \(k_{ex}\) as its regular continuation. For
<code>try...catch</code>, we need to replace the exception handler of \(e\) with a function
that evaluates \(e_{ex}\), using an outer exception handler on the overall
expression.</p>
<h2><a class="header" href="#remarks-7" id="remarks-7">Remarks</a></h2>
<ul>
<li>It's more explicit how the <code>raise</code> rule works if we instead translate to
<code>let k = (fn (x:t_ex) =&gt; k_ex x) in e'</code>. This is eta-reduced in the rule
given.</li>
</ul>
<h1><a class="header" href="#miscellaneous-other-notes" id="miscellaneous-other-notes">Miscellaneous Other Notes</a></h1>
<h2><a class="header" href="#extensible-variants" id="extensible-variants">Extensible Variants</a></h2>
<p>To complete our discussion of ML-like languages, we need a theory of extensible
variants. We will do this by adding a new type constructor \(\tau\ tag\), a reified
type tag that will be used to differentiate dynamically-added variants. It, and
the <code>exn</code> type, is defined by the rules</p>
<p>\[\require{bussproofs}
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau:*$}
\UnaryInfC{$\Gamma \vdash \tau\ tag:*$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash \tau:*$}
\UnaryInfC{$\Gamma \vdash newtag[\tau]:\tau\ tag$}
\end{prooftree} \qquad
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau\ tag$}
\AxiomC{$\Gamma \vdash e_2:\tau$}
\BinaryInfC{$\Gamma \vdash tag(e_1, e_2):exn$}
\end{prooftree}
\]
\[
\begin{prooftree}
\AxiomC{$\Gamma \vdash e_1:\tau\ tag$}
\AxiomC{$\Gamma \vdash e_2:exn$}
\AxiomC{$\Gamma, x:\tau \vdash e_3:\tau'$}
\AxiomC{$\Gamma \vdash e_4:\tau'$}
\QuaternaryInfC{$\Gamma \vdash iftag(e_1,e_2,x.e_3,e_4)$}
\end{prooftree}
\]</p>
<p>Evaluating <code>iftag</code> checks if the expression <code>e_2</code> is tagged with <code>e_1</code>. If so,
bind the captured \(\tau\) value to <code>x</code> in <code>e_3</code>, otherwise, evaluate <code>e_4</code>.</p>
<h2><a class="header" href="#the-initial-continuation" id="the-initial-continuation">The initial continuation</a></h2>
<p>One issue with our CPS-conversion translation is that we currently produce, as
our final program, a strange expression \(k.k_{ex}.e\), with these bound \(k\) and
\(k_{ex}\). At the top level, these are effectively free! To resolve this, we will
define the judgment</p>
<p>\[\Gamma \vdash_{prod} e:\tau \rightsquigarrow e'\]</p>
<p>for use on the top level program. We can then define</p>
<p>\[
\begin{prooftree}
\AxiomC{$\cdot \vdash e:\overline{\tau} \rightsquigarrow k.k_{ex}.e'$}
\UnaryInfC{$
\begin{aligned}
\cdot \vdash_{prod} e:\tau \rightsquigarrow
&amp;let\ k=\lambda(x:\overline{\tau}).halt\ in\\
&amp;let\ k_{ex} = \lambda(x:\overline{\tau_{ex}}).
(print\ \unicode{x201C}\text{uncaught exception}\unicode{x201D}; halt)\ in\\
&amp;e'
\end{aligned}
$}
\end{prooftree}
\]</p>
<p>(where <code>;</code> represents obvious sequencing)</p>
<p>Note that we simply throw the result of the entire program on the floor and
halt. With this setup, a program's practical usage is in its IO behavior, not
in the result of its evaluation. It is possible to set it up otherwise, but
that requires more complicated translations at the top level.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
